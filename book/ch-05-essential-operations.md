# 5 Հիմնական գործողություններ

_Երբ մեկը կասի, թե ուզում եմ այնպիսի ծրագրավորման լեզու, որտեղ ես միայն կասեմ, թե ինչ եմ ուզում, ապա նրա ձեռը մի շաքարաքլոր տվեք։_ ??

_— Ալան Պերլիս_

* [Ներածություն](#51-Ներածություն)
    * [Հիմնական գործողություններ](#511-Հիմնական-գործողություններ)
    * [Տիպերի ձևափոխություններ](#512-Տիպերի-ձևափոխություններ)
    * [Անդամների սկզբնարժեքավորիչներ](#513-Անդամների-սկզբնարժեքավորիչներ)
* [Պատճենում և տեղափոխում](#52-Պատճենում-և-տեղափոխում)
    * [Կոնտեյներների պատճենումը](#521-Կոնտեյներների-պատճենումը)
    * Կոնտեյներների փոխանակումը
* Ռեսուրսների կառավարում
* Conventional Operations
    * Comparisons
    * Container Operations
    * Input and Output Operators
    * User-Defined Literals
    * swap()
    * hash<>
* Խորհուրդներ


## 5.1 Ներածություն

Որոշ գործողություններ, ինչպիսիք են սկզբնարժեքավորումը, վերագրումը, պատճենումն ու տեղափոխումը, հիմնական են այն իմաստով, որ լեզվական կանոնները ինչ-որ նախապայմաններ ունեն դրանց համար։ Այլ գործողություններ, ինչպիսիք են, օրինակ, `==` և `<<`, ունեն սովորական իմաստ, որը վտանգավոր է անտեսել։ ??


### 5.1.1 Հիմնական գործողություններ

Շատ նախագծերում օբյեկտի կառուցումը առանցքային դեր է խաղում։ Կիրառությունների այդ ընդարձակ հնարավորություններն արտացոլվել են լեզվի՝ սկզբնարժեքավորումն ապահովող հնարավորությունների տեսականու և ճկունության վրա։

Տիպի կոնստրուկտորները, դեստրուկտորները, վերագրման ու տեղափոխման գործողությունները տրամաբանորեն անկախ չեն։ Մենք պետք է դրանք սահմանենք որպես համաձայնեցված խումբ կամ էլ տուժենք տրամաբանական ու արտադրողականության խնդիրների պատճառով։ Եթե `X` տիպն ունի ոչ հասարակ գործողություններ կատարող դեստրուկտոր, օրինակ, հիշողության ազատում կամ փականքի ազատում (lock release), ապա հավանաբար պետք է այդ դասի համար սահմանել ֆունկցիաների լրիվ հավաքածուն.

```C++
class X {
public:
    X(Sometype);            // «սովորական կոնստրուկտոր»: օբյեկտի ստեղծում
    X();                    // լռելության կոնստրուկտոր
    X(const X&);            // պատճենի կոնստրուկտոր
    X(X&&);                 // փոխանակման կոնստրուկտոր
    X& operator=(const X&); // պատճենող վերագրում. մաքրել օբյեկտը և պատճենել նոր արժեքը
    X& operator=(X&&);      // փոխանակող վերագրում. մաքրել օբյեկտը և տեղփոխել նոր արժեքը
    ~X();                   // դեստրուկտոր. մաքրող գործողություն
    // ...
};
```

Գոյություն ունեն հինգ իրավիճակներ, երբ օբյեկտը կարող է պատճենվել կամ տեղափոխվել.
* երբ այն վերագրվող արժեք է,
* երբ այն օբյեկտի սկզբնարժեքավորիչ է,
* երբ այն ֆունկցիայի արգումենտ է,
* երբ ֆունկցիայից վերադարձվող արժեք է,
* երբ բացառության օբյեկտ է։

Վերագրման ժամանակ օգտագործվում են վերագրման կամ փոխանակող վերագրման գործողությունները։ Սկզբունքորեն այլ դեպքերում կարելի է օգտագործել պատճենող կամ փոխանակող կանստրուկտորները։ Այնուամենայնիվ, պատճենող կամ տեղափոխող կանստրուկտորի կանչը սովորաբար օպտիմիզացվում է այնպես, որ արժեքավորման աջ կողմի օբյեկտը կառուցվում է հենց նպատակային օբյեկտի տեղում։

```C++
X make(Sometype);
X x = make(value);
```

Այս դեպքում կոմպիլյատորը սովորաբար `make()`-ից վերադարձվող `X`-ը կկառուցի ուղղակի `x`-ի մեջ՝ հապավելով պատճենումը։

Ի լրումն անվանված օբյեկտների և հիշողության դինամիկ տիրույթում ստեղծվող օբյեկտների սկզբնարժեքավորման, կոնստրուկտորներն օգտագործվում են ժամանակավոր օբյեկտների սկզբնարժեքավորման և տիպերի բացահայտ ձևափոխման համար։

Բացի «սովորական կոնստրուկտորը», կոմպիլյատորի կողմից այդ հատուկ ֆունկցիաները գեներացվում են ըստ անհրաժեշտության։ Եթե հատուկ ուզում եք, որ գեներացվի լռելության իրականացումը, ապա կարող եք գրել.

```C++
class Y {
public:
    Y(Sometype);
    Y(const Y&) = default;   // ես իսկապես ուզում եմ լռելության պատճենի կոնստրուկտորը
    Y(Y&&) = default;        // և լռելության տեղափոխող կոնստրուկտորը
    // ...
};
```

Եթե ընտրել եք ինչ-որ ֆունկցիաների լռելության իրականացումը, ապա այլ լռելության սահմանումներ չեն գեներացվի։ ??

եթե դասն ունի որևէ ցուցիչ անդամ, ապա սովորաբար առաջարկվում է բաահայտ իրականացնել պատճենի և տեղափոխման գործողությունները։ Պատճառն այն է, որ ցուցիչը կարող է ցույց տալ մի ինչ-որ բանի, որը դասը կուզենա ջնջել, և յդ դեպքում լռելության անդամ-առ-անդապ պատճենումը կարող է սխալ լինել։ Կամ էլ՝ ցուցիչը կարող է ցույց տալ մի բանի, որը դասը չպետք է ջնջի։ Երկու դեպքում էլ կոդը կարդացողը կուզենար դա իմանալ։ Օրինակ, տես §5.2.1։

Գործնական լավ կանոն է (երբեմն դրան ասում են _զրոյական կանոն_) կա՛մ սահմանել բոլոր հիմնական գործողությունները, կա՛մ ոչ մեկն էլ չսահմանել (բոլորի համար օգտագործել լռելության իրականացումները)։ Օրինակ.

```C++
struct Z {
    Vector v;
    string s;
};

Z z1;          // z1.v-ի և z1.s-ի լռելության արժեքավորում
Z z2 = z1;     // z1.v-ի և z1.s-ի լռելության պատճենում
```

Այս դեպքում կոմպիլյատորը, ըստ անհրաժեշտության, կգեներացնի լռելության կոնստրուկտոր, պատճենման ու տեղափոխման գործողություններ և դեստրուկտոր, և դրանք կունենան ճիշտ սեմանտիկա։ ??

Ի լրումն `= default` գրառման, գոյություն ունի նաև `= delete` գրառումը, որով նշվում է, որ գործողությունը չպետք է գեներացվի։ Դասերի հիերարխիայի բազային դասը այն դասական օրինակն է, որտեղ մենք չենք ուզում թույլ տալ անդամ-առ-անդամ պատճենոմը։ Օրինակ.

```C++
class Shape {
public:
    Shape(const Shape&) = delete;            // արգելել պատճենումը
    Shape& operator=(const Shape&) = delete;
    // ...
};

void copy(Shape& s1, const Shape& s2)
{
    s1 = s2;  // սխալ. Shape-ի պատճենումը ջնջված է
}
```

`= delete`-ի օգտագործման արդյունքում ջնջված ֆունկցիայի օգտագործման փորձը բերում է կոմպիլյացիայի ժամանակի սխալի։ `= delete`-ը կարելի է օգտագործել ոչ միայն հիմնական գործողությունների համար, այլև ցանկացած ֆունկցիայի համար։


### 5.1.2 Տիպերի ձևափոխություններ

Մեկ արգումենտով կոնստրուկտորը սահմանում է իր արգումենտի տիպի ձևափոխություն։ Օրինակ, `complex`-ը (§4.2.1) տրամադրում է `double` արգումենտով կոնստրուկտոր.

```C++
complex z1 = 3.14;  // z1-ը ստանում է {3.14, 0.0} արժեքը
complex z2 = z1*2;  // z2-ը ստանում է z1 * {2.0, 0} == {6.28, 0.0} արժեքը
```

Այս անբացահայտ ձևափոխությունը երբեմն իդեալական է, բայց ոչ միշտ։ Օրինակ, `Vector`-ն (§4.2.2) ունի `int` արգումենտով կոնստրուկտոր.

```C++
Vector v1 = 7; // լավ է. v1-ն ունի 7 տարր
```

Այսպիսի գառումը սովորաբար համարվում է անհաջող, և ստանդարտ գրադարանի վեկտորը թույլ չի տալիս `int`-ից `vector`-ի «ձևափոխություն»։

Այսպիսի խնդրից խուսափելու համար պետք է ասել, որ միայն բացահայտ «ձևափոխությունն» է թույլատրվում. այսինքն՝ կարող ենք կոնստրուկտորը սահմանել հետևյալ կերպ.

```C++
class Vector {
public:
    explicit Vector(int s);    // int-ից Vector-ի անբացահայտ ձևափոխությունն չի կարելի
    // ...
};
```

Ստանում ենք.

```C++
Vector v1(7);   // լավ է. v1-ն ունի 7 տարր
Vector v2 = 7;  // սխալ. int-ից Vector-ի անբացահայտ ձևափոխությունն չի կարելի
```

Հենց որ բանը հասնում է ձևափոխություններին՝ ավելի շատ տիպեր նման են `Vector`-ին քան `complex`-ին, հետևաբար, եթե հիմնավոր պատճառ չունեք, մեկ արգումենտով կոնստրուկտորի համար օգտագործեք `explicit`։


### 5.1.3 Անդամների սկզբնարժեքավորիչներ

Հենց որ սահմանվում է դասի անդամ-փոփոխականը, մենք կարող ենք դրա համար տրամադրել լռլության արժեքավորիչ՝ կոչված _անդամի լռելության սկզբնարժեքավորիչ_։ ??

```C++
class complex {
    double re = 0;
    double im = 0; // երկու double արժեքներ՝ 0.0 սկզբնական արժեքով
public:
    complex(double r, double i) : re{r}, im{i} {}   // complex-ը կառուցել երկու սկալյարներից. {r, i}
    complex(double r) : re{r} {}                    // complex-ը կառուցել մեկ սկալյարից. {r, 0}
    complex() {}                                    // լռելության կոնստրուկտոր {0, 0} արժեքի համար
    // ...
}
```

Երբ կոնստրուկտորով արժեքներ չեն տրվում, օգտագործվում են լռելության արժեքավորիչի արժեքները։ Սա պարզեցնում է կոդը և մեզ հնարավորություն է տալիս, որ պատահաբար փոփոխականը չթողնենք առանց սկզբնական արժեքի։ ??


## 5.2 Պատճենում և տեղափոխում

Լռելությամբ օբյեկտները կարող են պատճենվել։ Սա ճիշտ է ինչպես օգտագործողի սահմանած տիպերի, այնպես էլ ներդրված տիպերի համար։ Լռելությամբ կատարվում է անդամ-առ-անդամ պատճենում. ամեն մի անդամն առանձին պատճենվում է։ Օրինակ, օգտագործենք §4.2.1-ի `complex`-ը։

```C++
void test(complex z1)
{
    complex z2 {z1};    // պատճենող արժեքավորում
    complex z3;
    z3 = z2;            // պատճենող վերագրում
    // ...
}
```

Հիմա `z1`-ը, `z2`-ը և `z3`-ը ունեն նույն արժեքը, քանի որ թե՛ վերագրումը, թե՛ սկզբնարժեքավորումը պատճենում են դրանց երկու անդամն էլ։

Երբ դաս ենք նախագծում, ապա անպայման դիտարկում ենք, թե պե՞տք է արդյոք օբյեկտը պատճենվի, և թե ինչպես այն պետք է պատճենվի։ Պարզ կոնկրետ տիպերի համար անդամ-առ-անդամ պատճենումը սովորաբար հենց պատճենման ճիշտ իմաստն է։ Որոշ բարդ կոնկրետ տիպերի համար, ինչպիսին `Vector`-ն է, անդամ-առ-անդամ պատճենումը պատճենման ճիշտ իմաստը չէ. իսկ վերացական տիպերի համար համարյա միշտ այդպիսին չէ։ ??


### 5.2.1 Կոնտեյներների պատճենումը

Երբ դասը _ռեսուրսների նկարագրիչ_ է, այսիքն, պատասխանատու է օբյեկտի համար, որին հասանելիություն է ստանում ցուցիչի միջոցով, ապա լռելության անդամ-առ-անդամ պատճենումը սովորաբար գլխացավանք է։ Անդամ-առ-անդամ պատճենումը կարող է խախտել ռեսուրսների նկարագրիչի ինվերիանտը (§3.5.2)։ Օրինակ, լռելության պատճենումը կարող է թողնել, որ `Vector`-ի պատճենը հղվի նույն տարրերին, ինչ որ օրիգինալը։

```C++
void bad_copy(Vector v1)
{
    Vector v2 = v1;    // v1-ի ներկայացումը պատճենել v2-ի մեջ
    v1[0] = 2;         // v2[0]-ն էլ է հավասար 2-ի
    v2[1] = 3;         // v1[1]-ն էլ է հավասար 3-ի
}
```

Ենթադրենք՝ `v1`-ն ունի չորս տարր. արդյունքը գրաֆիկորեն կարելի է ներկայացնել հետևյալ կերպ.

![Վեկտորի պատճենում](images/image-011.jpeg)

Բարեբախտաբար, `Vector`-ի դեստրուկտոր ունենալու փաստը շատ լավ հուշում է, որ լռելության (անդամ-առ-անդամ) պատճենման սեմանտիկան սխալ է, և, այս օրինակի դեպքում, կոմպիլյատորը պետք է ամենաքիչը զգուշացում տա։ Մենք պետք է սահմանենք պատճենման ավելի լավ սեմանտիկա։

Դասի օբյեկտի պատճենման վարքը որոշվում է երկու անդամներով. պատճենի կոնստրուկտորով և պատճենող վերագրման գործողությամբ։

```C++
class Vector {
private:
    double* elem; // elem-ը ցույց է տալիս sz հատ double տարրերի
    int sz;

public:
    Vector(int s);                         // կոնստրուկտոր. հաստատել ինվարիանտը, ձեռք բերել ռեսուրսները
    ~Vector() { delete[] elem; }           // դեստրուկտոր. ազատել ռեսուրսները

    Vector(const Vector& a);               // պատճենի կոնստրուկտոր
    Vector& operator=(const Vector& a);    // պատճենող վերագրում

    double& operator[](int i);
    const double& operator[](int i) const;

    int size() const;
};
```
`Vector` դասի համար պատճենի կոնստրուկտորի ընդունելի սահմանումը պահանջված թվով տարրերի համար տեղ է առանձնացնում, ապա դրա մեջ է պատճենում տարրերը. արդյունքում `Vector`-ի ամեն մի նմուշն ունի տարրերի իր պատճենը։ ??

```C++
Vector::Vector(const Vector& a)   // պատճենող կոնստրուկտոր
    : elem{new double[a.sz]},     // տեղ առանձնացնել տարրերի համար
      sz{a.sz}
{
    for( int i = 0; i != sz; ++i )    // պատճենել տարրերը
        elem[i] = a.elem[i];
}
```

Ասվածից հետո `v2 = v1` արտահայտության արդյուքնը կարելի է ներկայացնել այսպես.

![Վեկտորի պատճենում](images/image-012.jpeg)

Իհարկե, ի լրումն պատճենի կոնստրուկտորի, պետք է ունենանք նաև պատճենող վերագրման գործողություն.

```C++
Vector& Vector::operator=(const Vector& a)     // պատճենող վերագրում
{
    double* p = new double[a.sz];
    for( int i = 0; i != a.sz; ++i )
        p[i] = a.elem[i];
    delete[] elem;         // ջնջել հին տարրերը
    elem = p;
    sz = a.sz;
    return *this;
}
```

`this` անունը անդամ ֆունկցիայում նախապես սահմանված է և ցույց է տալիս այն օբյեկտին, որի համար անդամ ֆունկցիան կանչվում է։

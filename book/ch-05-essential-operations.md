# 5 Հիմնական գործողություններ

_Երբ մեկը կասի, թե ուզում եմ այնպիսի ծրագրավորման լեզու, որտեղ ես միայն կասեմ, թե ինչ եմ ուզում, ապա նրա ձեռը մի շաքարաքլոր տվեք։_ ??

_— Ալան Պերլիս_

* [Ներածություն](#51-Ներածություն)
    * [Հիմնական գործողություններ](#511-Հիմնական-գործողություններ)
    * [Տիպերի ձևափոխություններ](#512-Տիպերի-ձևափոխություններ)
    * [Անդամների սկզբնարժեքավորիչներ](#513-Անդամների-սկզբնարժեքավորիչներ)
* [Պատճենում և տեղափոխում](#52-Պատճենում-և-տեղափոխում)
    * [Կոնտեյներների պատճենումը](#521-Կոնտեյներների-պատճենումը)
    * [Կոնտեյներների տեղափոխումը](#522-Կոնտեյներների-տեղափոխումը)
* [Ռեսուրսների կառավարում](#53-Ռեսուրսների-կառավարում)
* [Սովորական գործողություններ](#54-Սովորական-գործողություններ)
    * Համեմատումներ
    * Կոնտեյներների գործողություններ
    * Ներմուծման և արտածման գործողություններ
    * Օգտագործողի սահմանած լիտերալներ
    * `swap()`
    * `hash<>`
* [Խորհուրդներ](#55-Խորհուրդներ)


## 5.1 Ներածություն

Որոշ գործողություններ, ինչպիսիք են սկզբնարժեքավորումը, վերագրումը, պատճենումն ու տեղափոխումը, հիմնական են այն իմաստով, որ լեզվական կանոնները ինչ-որ նախապայմաններ ունեն դրանց համար։ Այլ գործողություններ, ինչպիսիք են, օրինակ, `==` և `<<`, ունեն սովորական իմաստ, որը վտանգավոր է անտեսել։ ??


### 5.1.1 Հիմնական գործողություններ

Շատ նախագծերում օբյեկտի կառուցումը առանցքային դեր է խաղում։ Կիրառությունների այդ ընդարձակ հնարավորություններն արտացոլվել են լեզվի՝ սկզբնարժեքավորումն ապահովող հնարավորությունների տեսականու և ճկունության վրա։

Տիպի կոնստրուկտորները, դեստրուկտորները, վերագրման ու տեղափոխման գործողությունները տրամաբանորեն անկախ չեն։ Մենք պետք է դրանք սահմանենք որպես համաձայնեցված խումբ կամ էլ տուժենք տրամաբանական ու արտադրողականության խնդիրների պատճառով։ Եթե `X` տիպն ունի ոչ հասարակ գործողություններ կատարող դեստրուկտոր, օրինակ, հիշողության ազատում կամ փականքի ազատում (lock release), ապա հավանաբար պետք է այդ դասի համար սահմանել ֆունկցիաների լրիվ հավաքածուն.

```C++
class X {
public:
    X(Sometype);            // «սովորական կոնստրուկտոր»: օբյեկտի ստեղծում
    X();                    // լռելության կոնստրուկտոր
    X(const X&);            // պատճենի կոնստրուկտոր
    X(X&&);                 // փոխանակման կոնստրուկտոր
    X& operator=(const X&); // պատճենող վերագրում. մաքրել օբյեկտը և պատճենել նոր արժեքը
    X& operator=(X&&);      // փոխանակող վերագրում. մաքրել օբյեկտը և տեղփոխել նոր արժեքը
    ~X();                   // դեստրուկտոր. մաքրող գործողություն
    // ...
};
```

Գոյություն ունեն հինգ իրավիճակներ, երբ օբյեկտը կարող է պատճենվել կամ տեղափոխվել.
* երբ այն վերագրվող արժեք է,
* երբ այն օբյեկտի սկզբնարժեքավորիչ է,
* երբ այն ֆունկցիայի արգումենտ է,
* երբ ֆունկցիայից վերադարձվող արժեք է,
* երբ բացառության օբյեկտ է։

Վերագրման ժամանակ օգտագործվում են վերագրման կամ փոխանակող վերագրման գործողությունները։ Սկզբունքորեն այլ դեպքերում կարելի է օգտագործել պատճենող կամ փոխանակող կանստրուկտորները։ Այնուամենայնիվ, պատճենող կամ տեղափոխող կանստրուկտորի կանչը սովորաբար օպտիմիզացվում է այնպես, որ արժեքավորման աջ կողմի օբյեկտը կառուցվում է հենց նպատակային օբյեկտի տեղում։

```C++
X make(Sometype);
X x = make(value);
```

Այս դեպքում կոմպիլյատորը սովորաբար `make()`-ից վերադարձվող `X`-ը կկառուցի ուղղակի `x`-ի մեջ՝ հապավելով պատճենումը։

Ի լրումն անվանված օբյեկտների և հիշողության դինամիկ տիրույթում ստեղծվող օբյեկտների սկզբնարժեքավորման, կոնստրուկտորներն օգտագործվում են ժամանակավոր օբյեկտների սկզբնարժեքավորման և տիպերի բացահայտ ձևափոխման համար։

Բացի «սովորական կոնստրուկտորը», կոմպիլյատորի կողմից այդ հատուկ ֆունկցիաները գեներացվում են ըստ անհրաժեշտության։ Եթե հատուկ ուզում եք, որ գեներացվի լռելության իրականացումը, ապա կարող եք գրել.

```C++
class Y {
public:
    Y(Sometype);
    Y(const Y&) = default;   // ես իսկապես ուզում եմ լռելության պատճենի կոնստրուկտորը
    Y(Y&&) = default;        // և լռելության տեղափոխող կոնստրուկտորը
    // ...
};
```

Եթե ընտրել եք ինչ-որ ֆունկցիաների լռելության իրականացումը, ապա այլ լռելության սահմանումներ չեն գեներացվի։ ??

եթե դասն ունի որևէ ցուցիչ անդամ, ապա սովորաբար առաջարկվում է բաահայտ իրականացնել պատճենի և տեղափոխման գործողությունները։ Պատճառն այն է, որ ցուցիչը կարող է ցույց տալ մի ինչ-որ բանի, որը դասը կուզենա ջնջել, և յդ դեպքում լռելության անդամ-առ-անդապ պատճենումը կարող է սխալ լինել։ Կամ էլ՝ ցուցիչը կարող է ցույց տալ մի բանի, որը դասը չպետք է ջնջի։ Երկու դեպքում էլ կոդը կարդացողը կուզենար դա իմանալ։ Օրինակ, տես §5.2.1։

Գործնական լավ կանոն է (երբեմն դրան ասում են _զրոյական կանոն_) կա՛մ սահմանել բոլոր հիմնական գործողությունները, կա՛մ ոչ մեկն էլ չսահմանել (բոլորի համար օգտագործել լռելության իրականացումները)։ Օրինակ.

```C++
struct Z {
    Vector v;
    string s;
};

Z z1;          // z1.v-ի և z1.s-ի լռելության արժեքավորում
Z z2 = z1;     // z1.v-ի և z1.s-ի լռելության պատճենում
```

Այս դեպքում կոմպիլյատորը, ըստ անհրաժեշտության, կգեներացնի լռելության կոնստրուկտոր, պատճենման ու տեղափոխման գործողություններ և դեստրուկտոր, և դրանք կունենան ճիշտ սեմանտիկա։ ??

Ի լրումն `= default` գրառման, գոյություն ունի նաև `= delete` գրառումը, որով նշվում է, որ գործողությունը չպետք է գեներացվի։ Դասերի հիերարխիայի բազային դասը այն դասական օրինակն է, որտեղ մենք չենք ուզում թույլ տալ անդամ-առ-անդամ պատճենոմը։ Օրինակ.

```C++
class Shape {
public:
    Shape(const Shape&) = delete;            // արգելել պատճենումը
    Shape& operator=(const Shape&) = delete;
    // ...
};

void copy(Shape& s1, const Shape& s2)
{
    s1 = s2;  // սխալ. Shape-ի պատճենումը ջնջված է
}
```

`= delete`-ի օգտագործման արդյունքում ջնջված ֆունկցիայի օգտագործման փորձը բերում է կոմպիլյացիայի ժամանակի սխալի։ `= delete`-ը կարելի է օգտագործել ոչ միայն հիմնական գործողությունների համար, այլև ցանկացած ֆունկցիայի համար։


### 5.1.2 Տիպերի ձևափոխություններ

Մեկ արգումենտով կոնստրուկտորը սահմանում է իր արգումենտի տիպի ձևափոխություն։ Օրինակ, `complex`-ը (§4.2.1) տրամադրում է `double` արգումենտով կոնստրուկտոր.

```C++
complex z1 = 3.14;  // z1-ը ստանում է {3.14, 0.0} արժեքը
complex z2 = z1*2;  // z2-ը ստանում է z1 * {2.0, 0} == {6.28, 0.0} արժեքը
```

Այս անբացահայտ ձևափոխությունը երբեմն իդեալական է, բայց ոչ միշտ։ Օրինակ, `Vector`-ն (§4.2.2) ունի `int` արգումենտով կոնստրուկտոր.

```C++
Vector v1 = 7; // լավ է. v1-ն ունի 7 տարր
```

Այսպիսի գառումը սովորաբար համարվում է անհաջող, և ստանդարտ գրադարանի վեկտորը թույլ չի տալիս `int`-ից `vector`-ի «ձևափոխություն»։

Այսպիսի խնդրից խուսափելու համար պետք է ասել, որ միայն բացահայտ «ձևափոխությունն» է թույլատրվում. այսինքն՝ կարող ենք կոնստրուկտորը սահմանել հետևյալ կերպ.

```C++
class Vector {
public:
    explicit Vector(int s);    // int-ից Vector-ի անբացահայտ ձևափոխությունն չի կարելի
    // ...
};
```

Ստանում ենք.

```C++
Vector v1(7);   // լավ է. v1-ն ունի 7 տարր
Vector v2 = 7;  // սխալ. int-ից Vector-ի անբացահայտ ձևափոխությունն չի կարելի
```

Հենց որ բանը հասնում է ձևափոխություններին՝ ավելի շատ տիպեր նման են `Vector`-ին քան `complex`-ին, հետևաբար, եթե հիմնավոր պատճառ չունեք, մեկ արգումենտով կոնստրուկտորի համար օգտագործեք `explicit`։


### 5.1.3 Անդամների սկզբնարժեքավորիչներ

Հենց որ սահմանվում է դասի անդամ-փոփոխականը, մենք կարող ենք դրա համար տրամադրել լռլության արժեքավորիչ՝ կոչված _անդամի լռելության սկզբնարժեքավորիչ_։ ??

```C++
class complex {
    double re = 0;
    double im = 0; // երկու double արժեքներ՝ 0.0 սկզբնական արժեքով
public:
    complex(double r, double i) : re{r}, im{i} {}   // complex-ը կառուցել երկու սկալյարներից. {r, i}
    complex(double r) : re{r} {}                    // complex-ը կառուցել մեկ սկալյարից. {r, 0}
    complex() {}                                    // լռելության կոնստրուկտոր {0, 0} արժեքի համար
    // ...
}
```

Երբ կոնստրուկտորով արժեքներ չեն տրվում, օգտագործվում են լռելության արժեքավորիչի արժեքները։ Սա պարզեցնում է կոդը և մեզ հնարավորություն է տալիս, որ պատահաբար փոփոխականը չթողնենք առանց սկզբնական արժեքի։ ??


## 5.2 Պատճենում և տեղափոխում

Լռելությամբ օբյեկտները կարող են պատճենվել։ Սա ճիշտ է ինչպես օգտագործողի սահմանած տիպերի, այնպես էլ ներդրված տիպերի համար։ Լռելությամբ կատարվում է անդամ-առ-անդամ պատճենում. ամեն մի անդամն առանձին պատճենվում է։ Օրինակ, օգտագործենք §4.2.1-ի `complex`-ը։

```C++
void test(complex z1)
{
    complex z2 {z1};    // պատճենող արժեքավորում
    complex z3;
    z3 = z2;            // պատճենող վերագրում
    // ...
}
```

Հիմա `z1`-ը, `z2`-ը և `z3`-ը ունեն նույն արժեքը, քանի որ թե՛ վերագրումը, թե՛ սկզբնարժեքավորումը պատճենում են դրանց երկու անդամն էլ։

Երբ դաս ենք նախագծում, ապա անպայման դիտարկում ենք, թե պե՞տք է արդյոք օբյեկտը պատճենվի, և թե ինչպես այն պետք է պատճենվի։ Պարզ կոնկրետ տիպերի համար անդամ-առ-անդամ պատճենումը սովորաբար հենց պատճենման ճիշտ իմաստն է։ Որոշ բարդ կոնկրետ տիպերի համար, ինչպիսին `Vector`-ն է, անդամ-առ-անդամ պատճենումը պատճենման ճիշտ իմաստը չէ. իսկ վերացական տիպերի համար համարյա միշտ այդպիսին չէ։ ??


### 5.2.1 Կոնտեյներների պատճենումը

Երբ դասը _ռեսուրսների նկարագրիչ_ է, այսիքն, պատասխանատու է օբյեկտի համար, որին հասանելիություն է ստանում ցուցիչի միջոցով, ապա լռելության անդամ-առ-անդամ պատճենումը սովորաբար գլխացավանք է։ Անդամ-առ-անդամ պատճենումը կարող է խախտել ռեսուրսների նկարագրիչի ինվերիանտը (§3.5.2)։ Օրինակ, լռելության պատճենումը կարող է թողնել, որ `Vector`-ի պատճենը հղվի նույն տարրերին, ինչ որ օրիգինալը։

```C++
void bad_copy(Vector v1)
{
    Vector v2 = v1;    // v1-ի ներկայացումը պատճենել v2-ի մեջ
    v1[0] = 2;         // v2[0]-ն էլ է հավասար 2-ի
    v2[1] = 3;         // v1[1]-ն էլ է հավասար 3-ի
}
```

Ենթադրենք՝ `v1`-ն ունի չորս տարր. արդյունքը գրաֆիկորեն կարելի է ներկայացնել հետևյալ կերպ.

![Վեկտորի պատճենում](images/image-011.jpeg)

Բարեբախտաբար, `Vector`-ի դեստրուկտոր ունենալու փաստը շատ լավ հուշում է, որ լռելության (անդամ-առ-անդամ) պատճենման սեմանտիկան սխալ է, և, այս օրինակի դեպքում, կոմպիլյատորը պետք է ամենաքիչը զգուշացում տա։ Մենք պետք է սահմանենք պատճենման ավելի լավ սեմանտիկա։

Դասի օբյեկտի պատճենման վարքը որոշվում է երկու անդամներով. պատճենի կոնստրուկտորով և պատճենող վերագրման գործողությամբ։

```C++
class Vector {
private:
    double* elem; // elem-ը ցույց է տալիս sz հատ double տարրերի
    int sz;

public:
    Vector(int s);                         // կոնստրուկտոր. հաստատել ինվարիանտը, ձեռք բերել ռեսուրսները
    ~Vector() { delete[] elem; }           // դեստրուկտոր. ազատել ռեսուրսները

    Vector(const Vector& a);               // պատճենի կոնստրուկտոր
    Vector& operator=(const Vector& a);    // պատճենող վերագրում

    double& operator[](int i);
    const double& operator[](int i) const;

    int size() const;
};
```
`Vector` դասի համար պատճենի կոնստրուկտորի ընդունելի սահմանումը պահանջված թվով տարրերի համար տեղ է առանձնացնում, ապա դրա մեջ է պատճենում տարրերը. արդյունքում `Vector`-ի ամեն մի նմուշն ունի տարրերի իր պատճենը։ ??

```C++
Vector::Vector(const Vector& a)   // պատճենող կոնստրուկտոր
    : elem{new double[a.sz]},     // տեղ առանձնացնել տարրերի համար
      sz{a.sz}
{
    for( int i = 0; i != sz; ++i )    // պատճենել տարրերը
        elem[i] = a.elem[i];
}
```

Ասվածից հետո `v2 = v1` արտահայտության արդյուքնը կարելի է ներկայացնել այսպես.

![Վեկտորի պատճենում](images/image-012.jpeg)

Իհարկե, ի լրումն պատճենի կոնստրուկտորի, պետք է ունենանք նաև պատճենող վերագրման գործողություն.

```C++
Vector& Vector::operator=(const Vector& a)     // պատճենող վերագրում
{
    double* p = new double[a.sz];
    for( int i = 0; i != a.sz; ++i )
        p[i] = a.elem[i];
    delete[] elem;         // ջնջել հին տարրերը
    elem = p;
    sz = a.sz;
    return *this;
}
```

Նախապես սահմանված `this` անունը անդամ ֆունկցիայում ցույց է տալիս այն օբյեկտին, որի համար անդամ ֆունկցիան կանչվում է։


### 5.2.2 Կոնտեյներների տեղափոխումը

Պատճենումը կարող ենք կառավարել պատճենի կոնստրուկտոր և պատճենող վերագրում սահմանելով, սակայն պատճենումը կարող է ծախսատար լինել մեծ օբյկտների համար։ Մենք խուսափում ենք պատճենման ծախսերից, երբ օբյեկտը ֆունկցիային ենք փոխանցում հղումով, բայց մենք չենք կարող որպես արդյունք վերադարձնել լոկալ օբյեկտի հղումը (լոկալ օբյեկտը կքանդվի, հենց որ կանչող ֆունկցիան հնարավորություն ստանա դիմել դրան): ?? Դիտարկենք հետևյալը.

```C++
Vector operator+(const Vector& a, const Vector& b)
{
    if( a.size()!=b.size() )
        throw Vector_size_mismatch{};

    Vector res(a.size());
    for( int i = 0; i != a.size(); ++i )
        res[i] = a[i] + b[i];
    return res;
}
```

`operator+`-ից վերադառնալիս արդյունքը `res` լոկալ փոփոխականից պատճենվում է մի այնպիսի տեղ, որտեղից այն հասանելի կլինի կանչող ֆունկցիային։ `+`-ը կարող ենք օգտագործել հետևյալ կերպ.

```C++
void f(const Vector& x, const Vector& y, const Vector& z)
{
    Vector r;
    // ...
    r = x + y + z;
    // ...
}
```

Այստեղ `Vector`-ը պատճենվելու է ամենաքիչը երկու անգամ (`+` գործողության ամեն մի օգտագործման համար մեկական անգամ)։ Եթե `Vector`-ը մեծ է, ասենք՝ 10000 `double`-ներով, դա արդեն կարող է մտահոգիչ լինել։ Ամենամտահոգիչն այն է, որ `operator+()`-ում պատճենումից հետո `res`-ն այլևս չի օգտագործվում։ Իրականում մեզ պատճենել պետք էլ չէ. մեզ միայն պետք է արդյունքը դուրս բերել ֆունկցիայից. մենք կուզենայինք _պատճենելու_ փոխարեն _տեղափոխել_ `Vector`-ը։ Բարեբախտաբար, կարող ենք արտահայտել այդ մտադրությունը.

```C++
class Vector {
    // ...

    Vector(const Vector& a);               // պատճենի կոնստրուկտոր
    Vector& operator=(const Vector& a);    // պատճենող վերագրում

    Vector(Vector&& a);                    // տեղափոխման կոնստրուկտոր
    Vector& operator=(Vector&& a);         // տեղափոխող վերագրում
};
```

Ունենալով այս սահմանումը՝ ֆունկցիայից վերադարձվող արժեքի դուրս բերելն իրականացնելու համար, կոմպիլյատորը կընտրի _տեղափոխման կոնստրուկտորը_։ Սա նշանակում է, որ `r = x + y + z` արտահայտության հաշվարը չի բեր `Vector`-ների պատճենման։ Դրա փոխարեն `Vector`-ները պարզապես կտեղափոխվեն։

Սովերաբար շատ հեշտ է սահմանել `Vector`-ի տեղափոխման կոնստրուկտորը.

```C++
Click here to view code image

Vector::Vector(Vector&& a)
    : elem{a.elem},          // "խլել տարրերը" a-ից
      sz{a.sz}
{
    a.elem = nullptr;       // a-ն այլևս տարրեր չունի
    a.sz = 0;
}
```

Նիշերի `&&` զույգը նշանակում է «աջակողմյան արժեքի հղում» (rvalue reference). այն հղում է, որին կարող ենք կապել աջակողմյան արժեք (rvalue): ?? rvalue բառը հակադիրն է lvalue բառի, որը պարզապես նշանակում է «ինչ-որ բան, որը կարող է հանդիպել վերագրման գործողության ձախ կողմում»։ Այսինքն, աջակողմյան արժեքը կամ r-արժեքը, առաջին մոտարկմամբ, մի արժեք է, որին չի կարելի վերագրել, օրինակ, ֆունկցիայից վերադարձրած ամբողջ թիվ։ ?? Այսպիսով, r-արժեքի հղումը ինչ-որ մի բանի հղում է, որին _ուրիշ ոչ մեկը_ չի կարող վերագրել, հետևաբար կարող ենք բարեհաջող կերպով «գողանալ» գրա արժեքը։ `Vector-ների համար գրած `operator+()`-ի `res` լոկալ փոփոխականը այդպիսի մի օրինակ է։

Տեղափոխող կոնստրուկտորի արգումենտը `const` _չէ_. ամեն ինչից բացի ենթադրվում է, որ տեղափոխող կոնստրուկտորը իր արգումենտից հեռացնում է արժեքը։ ?? Նույն կերպ է սահմանվում նաև տեղափոխող վերագրման գործողությունը։

Տեղափոխման գործողությունը կիրառվում է, երբ r-արժեքի հղումն ոգտագործվցած է կամ որպես սկզբնարժեքավորիչ, կամ որպես վերագրման աջ կողմի արժեք։

Տեղափոխումից հետո օբյեկտը, որից կատորվել է տեղափոխումը, պետք է գտնվի այնպիսի վիճակում, որը թույլ է տալիս դեստրուկտորի աշխատեցնելը։ ?? Սովորաբար տեղափոխման ենթարկված օբյեկտին թույլատում ենք նաև վերագրել։ Դա ենթադրում են նաև ստանդարտ գրադարանի ալգորիթմները (Գլուխ 12)։ Մեր `Vector`-ը նույնպես դա թույլ է տալիս։

Այն տեղերում, որտեղ ծրագրավորողը գիտի, որ արժեքն այլևս չի օգտագործվելու, սակայն կոմպիլյատորն էլ բավարարար խելացի չէ դա հասկանալու համար, ծրագրավորողը կարող է հատուկ հուշել նրան.

```C++
Vector f()
{
    Vector x(1000);
    Vector y(2000);
    Vector z(3000);
    z = x;              // պատճենում (x-ը f()-ում դեռ էլի է օգտագործվելու)
    y = std::move(x);   // տեղափոխում (տեղափոխող վերագրում)
    // ... ավելի լավ է x-ն այստեղ չօգտագործել ...
    return z;           // տեղափոխում
}
```

Իրականում ստանդարտ գրադարանի `move()` ֆունկցիան ոչինչ էլ չի տեղափոխում։ Դրա փոխարեն նա վերադարձնում է իր արգումենտի հղումը, որից կարող ենք տեղափոխում անել — r-արժեքի հղում. `move()`-ը տիպի համաձայնեցման (cast) մի տարատեսակ է։

Հենց `return`-ից առաջ ունենք հետևյալը.

![Տեղափոխում](images/image-013.jpeg)

Երբ ավարտվում է `f()`-ը, `z`-ը քանդվում է իր տարրերը `return`-ի միջոցով `f()`-ից դուրս տեղափոխելուց հետո։ Այնուամենայնիվ, `y`-ի դեստրուկտորը `delete[]` կկիրառի իր տարրերի համար։

Կոմպիլյատորը պատավորված է (C++-ի ստանդարտով) կրճատել սկզբնարժեքավորման հետ կապված պատճենումների մեծ մասը, այսինքն՝ տեղափոխման կոնստրուկտորները չեն կանչվում այնպես հաճախ, ինչպես դուք պատկերացնում եք։ _Պատճենումների կրճատումը_ (copy elision) կրճատում է նաև տեղափոխման հետ կապված ավելորդ գործողությունների մի փոքր մասը։ Մյուս կողմից էլ, սովորաբար հնարավոր չէ վերագրման գործողություններից անվերապահ բացառել պատճենումը կամ տեղափոխումը, հետևաբար տեղափոխող վերագրումը կարող է էական նշանակություն ունենալ արտադրողականության համար։


## 5.3 Ռեսուրսների կառավարում

Կոնստրուկտորներ, պատճենող գործողություններ, տեղափոխման գործողություններ և դեստրուկտոր սահմանելով ծրագրավորողը կարող է լիարժեք վերահսկողություն տրամադրել ձեռք բերված ռեսուրսի (օրինակ, կոնտեյների տարրեր) կյանքի տևողության համար։ Բացի այդ, տեղափոխման կոնստրուկտորը օբյեկտին թույլ է տալիս պարզ ու առանց մեծ ծախսերի տեղափոխվել մի տիրույթից մյուսը։ Այդ եղանակով, օբյեկտները, որոնք մենք չենք կարող կամ չենք ուզում պատճենել ընթացիկ տեսանելիության տիրույթից, կարող են հեշտ ու առանց ծախսերի տեղափոխվել։ ?? Դիտարկենք ստանդարտ գրադարանի `thread`-ը, որով կատարվում է զուգընթաց (concurrent, §15.2) գործողություն, և միլիոն `double`-ներ պարունակող վեկտոր։ Մենք չենք կարող պատչենել `thread`-ը, իսկ վեկտորն էլ չենք ուզում պատճենել։

```C++
std::vector<thread> my_threads;

Vector init(int n)
{
    thread t {heartbeat};                 // զուգընթացորեն աշխատեցնել heartbeat-ը (առանձին thread-ում)
    my_threads.push_back(std::move(t));   // t-ն տեղափոխել my_threads-ի մեջ (§13.2.2)
    // ... այլ արժեքավորումներ ...

    Vector vec(n);
    for( int i = 0; i != vec.size(); ++i )
        vec[i] = 777;
    return vec;                      // vec-ը տեղափոխել init()-ից դուրս
}

auto v = init(1'000'000);     // սկսել heartbeat-ը և արժեքավորել v-ն
```

Ռեսուրսների նկարագրիչները, ինչպիսիք են `Vector`-ը և `thread`-ը, շատ դեպքերում ներդրված ցուցիչների ուղղակի օգտագործման նախընտրելի այլընտրանքներն են։ Ըստ էության, ստանդարտ գրադարանի «խելացի ցուցիչները» (smart pointers), օրինակ, `unique_ptr`, հենց ռեսուրսների նկարագրիչներ են (§13.2.1)։

Հոսքերը (thread) պահելու համար ես օգտագործել եմ ստանդարտ գրադարանի `vector`-ը, որովհետև չենք կարող մեր հասարակ `Vector`-ը պարամետրիզացնել տարրի տիպով, քանի դեռ չենք հասել §6.2-ին։

Շատ նման այն եղանակին, որով `new` և `delete` գործողություններն են անհետանում ծրագրի կոդից, կարող ենք այնպես անել, որ ցուցիչները կորեն ռեսուրսների նկարագրիչների մեջ։ Երկու դեպքում էլ արդյունքն ավելի պարզ ու ավելի սպասարկելի կոդն է՝ առանց լրացուցիչ բարդությունների։ Մասնավորապես, կարող ենք հասնել _ռեսուրսների խիստ ապահովության_. այսինքն՝ կարող ենք բացառել ռեսուրսներ արտահոսքն ընդհանրապես ռեսուրս հասկացության համար։ Օրինակներ են հիշողության տիրույթի հետ կապված `vector`-ները, համակարգային հոսքերի հետ կապված `thread`-ները, և ֆայլերի նկարագրիչների հետ կապված `fstream`-ները։

Շատ լեզուներում ռեսուրսների կառավարումը հիմնականում հանձնարարվում է աղբի հավաքման մեխանիզմին (garbage collector)։ C++-ն էլ է առաջարկում աղբի հավաքման ինտերֆեյս՝ թույլ տալով ձեզ տրամադրել աղբի հավաքման մեխանիզմի իրականացում։ Այնուամենայնիվ, աղբի հավաքման մեխանիզմը ես դիտարկում եմ որպես վերջին տարբերակ, այն դեպքի համար, երբ սպառվել են ռեսուրսների կառավարման ավելի մաքուր, ավելի ընդհանուր, ավելի տեղայնացված միջոցները։ Իմ իդեալն է՝ որևէ աղբ չստեղծել, դրանով իսկ բացառել աղբի հավաքման անհրաժեշտությունը. Մի՛ աղտոտեք։

Աղբի հավաքումն իր էությամբ հիշողության գլոբալ կառավարման սխեմա է։ Հնարամիտ իրականացումները կարող են փոխհատուցել գլուբալության թերությունները, բայց հենց որ համակարգերը դառնում են ավելի ու ավելի բաշխված (հիշեք քեշերը, բազմամիջուկ պրոցեսորները և կոմպյուտերային կլաստերները), լոկալությունը դառնում է ավելի կարևոր, քան երբեք։

Բայցի այդ, հիշողությունը միակ ռեսուրսը չէ։ Ռեսուրս է այն ամենը, ինչը պետք է ձեռք բերվի և (բացահայտ կամ անբացահայտ) ազատվի օգտագործումից հետո։ Օրինակներ են հիշողությունը, փականները (lock), սոկետները, ֆայլերի նկարագրիչները և հոսքերի նկարագրիչները։ Անակնկկալ չէ, որ ռեսուրսը, որը պարզապես հիշողություն չէ, կոչվում է _հիշողություն չհանդիսացող ռեսուրս_ (non-memory resource)։ Ռեսուրսների կառավարման լավ համակարգն աշխատում է ռեսուրսների բոլոր տեսակների հետ։ Հիշողության արտահոսքերը պետք է բացառվեն երկար աշխատող ցանկացած համակարգում, բայց ռեսուրսի չափազանց երկար պահելը կարող է նույնքան վատ լինել, որքան արտահոսքն է։ Օրինակ, եթե համակարգը հիշողության տիրույթը, փականը, ֆայլերը և այլն պահում է երկու անգամ ավելի երկար, ապա հավանական է, որ այդպիսի համակարգին պետք կլինի հարկավորից երկու անգամ ավելի շատ ռեսուրսներ։ ??

Մինչև աղբի հավաքումն օգտագործելը համակարգված օգտագործեք ռեսուրսների նկարագրիչները. թող որ ամեն մի ռեսուրսն ունենա իր «տերը» որևէ տեսանելիության տիրույթում, և թող այդ ռեսուրսն ազատվի իր տիրոջ տեսանելիության տիրույթի վերջում։ C++-ում դա կոչվում է RAII (Resource Acquisition Is Initialization, ռեսուրսի ձեռքբերումը հենց սկզբնարժեքավորւմ է) և ներդրված է սխալների մշակման մեջ՝ բացառությունների տեսքով։ ?? Տեղափոխման սեմանտիկայի կամ «խելացի ցուցիչների» օգտագործմամբ ռեսուրսները կարող են տեղափոխվել մի տեսանելիության տիրույթից մյուսը, իսկ համատեղ օգտագործումը կարող է ներկայացվել «shared pointer»-ներով (§13.2.1)։

C++-ի ստանդարտ գրադարանում RAII—ն համատարած է. օրինակ, հիշողության (`string`, `vector`, `map`, `unordered_map` և այլն), ֆայլերի (`ifstream`, `ofstream` և այլն), հոսքերի (`thread`), փականների (`lock_guard`, `unique_lock` և այլն), և ընդհանրապես օբյեկտների համար (`unique_ptr`-ի և `shared_ptr`-ի միջոցով)։ Արդյունքը ռեսուրսների անբացահայտ կառավարումն է, որը տեսանելի չէ ընդհանուր դեպքերում և բերում է ռեսուրսների պահման կարճ ժամանակների։ ???


## 5.4 Սովորական գործողություններ

Որոշ գործողություններ ունեն սովորական, ընդունված իմաստ, երբ սահմանվում են տիպի համար։ Այդ սովորական իմաստները հաճախ ենթադրվում են ծրագրավորողների ու գրադարանների կողմից (հատկապես՝ ստանդարտ գրադարանը), հետևաբար նոր տիպեր սահմանելիս, որոնց համար այդ գործողություններն իմաստ ունեն, կարևոր է պահպանել համապատասխանությունը։ ??

* Համեմատություններ. `==`, `!=`, `<`, `<=`, `>` և `>=` (§5.4.1)։
* Կոնտեյներների գործողություններ. `size()`, `begin()` և `end()` (§5.4.2)։
* Ներմուծման ու արտածման գործողություններ `>>` և `<<` (§5.4.3)։
* Օգտագործողի սահմանած լիտերալներ (§5.4.4)։
* `swap()` (§5.4.5)։
* Հեշ (hash) ֆունկցիաներ. `hash<>` (§5.4.6)։


### 5.4.1 Համեմատումններ

Հավասարության համեմատությունների (`==` և `!=`) իմաստը սերտ կապված է պատճենման հետ։ Պատճենումից հետո պատճենները պետք է հավասար լինեն.

```C++
X a = something;
X b = a;
assert(a == b);  // եթե այստեղ a != b, ապա մի բան այն չէ (§3.5.4)
```

Երբ սահմանում եք `==`-ը, սահմանեք նաև `!=` և համոզվեք, որ `a != b` նշանակում է `!(a == b)`։

Նմանապես, եթե սահմանում եք `<`-ը, ապա սահմանեք նաև `<=`-ը, `>`-ը, `>=`-ը, և համոզվեք, որ տեղի ունեն սովորական հարաբերությունները.

* `a <= b` նշանակում է `(a < b) || (a == b)` և `!(b < a)`։
* `a > b` նշանակում է `b < a`։
* `a >= b` նշանակում է `(a > b) || (a == b)` և `!(b < a)`։

Երկտեղանի գործողության, ինչպիսին է `==`-ը, երկու օպերանդներն էլ նույնատիպ մեկնաբանություն տալու համար ավելի լավ է այն սահմանել որպես ազատ ֆունկցիա՝ իր դասի անունների տիրույթում։ Օրինակ.

```C++
namespace NX {
    class X {
        // ...
    };
    bool operator==(const X&, const X&);
    // ...
};
```


### 5.4.2 Կոնտեյներների գործողություններ

Կոնտեյներները նախագծեք ստանդարտ գրադարանի կոնտեյներների (Գլուխ 11) ոճով, եթե այդպես չանելու հիմնավոր պատճառ չունեք։ Մասնավորապես, կոնտեյները դարձրեք ռեսուրսների հետ աշխատելու տեսակետից ապահով՝ այն իրականացնելով որպես համապատասխան հիմնական գործողություններով ռեսուրսների նկարագրիչ (§5.1.1, §5.2)։

Ստանդարտ գրադարանի բոլոր կոնտեյներները գիտեն իրենց տարրերի քնակը, և մենք կարող ենք այն ստանալ `size()`-ի կանչով։ Օրինակ.

```C++
for (size_t i = 0; i < c.size(); ++i)    // size_t-ն ստանդարտ գրադարանի size()-ի վերադարձրած արժեքի տիպն է
      c[i] = 0;
```

Սակայն, կոնտեյների տարրերը `0`-ից մինչև `size()` ինդեքսներով թվարկելու փոխարեն, ստանդարտ ալգորիթմները (Գլուխ 12) օգտագործում են երկու իտերատորներով որոշվող _հաջորդականության_ գաղափարը.

```C++
for (auto p = c.begin(); p != c.end(); ++p)
      *p = 0;
```

Այստեղ `c.begin()`-ը `c`-ի առաջին տարրին ցույց տվող իտերատորն է, իսկ `c.end()`-ը՝ վերջին տարրին հաջորդող դիրքի իտերատորը։ Ինչպես և ցուցիչները, իտերատորներն էլ `++` գործողությամբ անցնում են հաջորդ տարրին և `*` գործողությամբ հասանելիություն են տրամադրում իրենց ցույց տրված տարրին։ ?? Իտերատորների այս մոդելն (§12.3) ապահովում է մեծ ընդհանրացվածություն և արդյունավետություն։ Իտերատորներն օգտագործվում են նաև հաջորդականությունները ստանդարտ գրադարանի ալգորիթմներին փոխանցելու համար։ Օրինակ.

```C++
sort(v.begin(),v.end());
```

Մանրամասների համար և կոնտեյներների այլ գործողություններին ծանոթանալու համար կարդացեք Գլուխ 11-ը և Գլուխ 12-ը։

Տարրերի քանակը ոչ բացահայտորեն օգտագործելու մի այլ եղանակ է միջակայքերի-`for` ցիկլի հրամանը։

```C++
for (auto& x : c)
      x = 0;
```

Այստեղ `c.begin()`-ի  և `c.end()`-ի թաքնված օգտագործումն է և այն ինչ-որ իմաստով համարժեք է բացահայտ ցիկլին։


### 5.4.3 Ներմուծման և արտածման գործողություններ

Ամբողջ թվերի զույգի համար `<<` գործողությունը նշանակում է տեղաշարժ դեպի ձախ, իսկ `>>` գործողությունը՝ տեղաշարժ դեպի աջ։ Սակայն `iostream`-ների համար դրանք համապատսխանաբար ներմուծման և արտածման գործողություններն են (§1.8, Գլուխ 10)։ Մանրամասների և այլ Ն/Ա գործողությունների համար տես Գլուխ 10-ը։


### 5.4.4 Օգտագործողի սահմանած լիտերալներ

Դասերի նպատակներից մեկը եղել է ծրագրավորողին հնարավորություն տալ նախագծել ու իրականացնել տիպեր, որոնք շատ նման են ներդրված տիպերին։ ?? Կոնստրուկտորներով ապահովվում է սկզբնարժեքավորումը, որը համարժեք է կամ գերազանցում է ներդրված տիպերի ճկունությանն ու արդյունավետությանը, սակայն ներդրված տիպերի համար ունենք լիտերալներ.

* `123`-ը `int` է։
* `0xFF00u`-ը `unsigned int` է։
* `123.456`-ը `double` է։
* `"Surprise!"`-ը `const char[10]` է։

Այսպիսի լիտերալների տրամադրումը կարող է օգտակար լինել նաև օգտագործողի սահմանած տիպերի համար։ Դա արվում է լիտերալի վերջածանցի իմաստի սահմանումով, որից ստանում ենք.

* `"Surprise!"s`-ը `std::string` է։
* `123s`-ը `seconds` է։
* `12.7i`-ը `imaginary` է, և `12.7i+47`-ը `complex` թիվ է (այսինքն՝ `{47,12.7}`)։

Մասնավորապես, այդ օրինակները կարող ենք տեսնել ստանդարտ գրադարանում՝ օգտագործելով համապատասխան վերնագրային ֆայլերը և անունների տիրույթները։

|                 | Ստանդարտ գրադարանի վերջածանցները լիտերալների համար |                |
|-----------------|----------------------------------------|----------------|
| `<chrono>`      | `std::literals::chrono_literals`  | `h`, `min`, `s`, `ms`, `us`, `ns` |
| `<string>`      | `std::literals::string_literals`  | `s`                     |
| `<string_view>` | `std::literals::string_literals`  | `sv`                    |
| `<complex>`     | `std::literals::complex_literals` | `i`, `il`, `if`             |

Զարմանալի չէ, որ օգտագործողի սահմանած վերջածանցով լիտերալները կոչվում են _օգտագործողի սահմանած լիտերալներ_ կամ UDL-ներ: Այդպիսի լիտերալները սահմանվում են _լիտերալի գործողությամբ_։ Լիտերալի գործողությունն իր արգումենտում տրված և վերջածանցով նշված լիտերալը ձձափոխում է իր վերադարձվող արժեքի տիպի։ Օրինակ, կեղծ թվի `i` վերջածանցը կարելի է իրականացնել հետևյալ կերպ.

```C++
constexpr complex<double> operator""i(long double arg)     // imaginary literal
{
    return {0,arg};
}
```

Այստեղ.

* `operator""` գրառումը ցույց է տալիս, որ սահմանում ենք լիտերալի գործողություն։
* «Լիտերալի նիշերից» հետո գրված `i`-ն այն վերջածանցն է, որի համար իմաստ է սահմանվում։
* Արգումենտի `long double` տիպը ցույց է տալիս, որ տվյալ վերջածանցը սահմանվում է սահող կետով լիտերալի համար։
* Վերադարձվող արժեքի `complex<double>` տիպը որոշում է արդյունքում ստացվող լիտերալի տիպը։ ??

Սա ունենալով՝ կարող ենք գրել.

```C++
complex<double> z = 2.7182818 + 6.283185i;
```

### 5.4.5 `swap()`

Շատ ալգորիթմներ, հատկապես `sort()`-ը, օգտագործում են երկու օբյեկտների արժեքները փոխանակող `swap()` ֆունկցիան։ Սովորաբար այս ալգորիթմները ենթադրում են, որ `swap()`-ը շատ արագ է և բացառություններ չի գեներացնում։ Ստանդարտ գրադարանը տրամադրում է `std::swap(a, b)`-ն՝ իրականացված երեք տեղափոխման գործողություններով. (`tmp = a`, `a = b`, `b = tmp`)։ Եթե տիպ եք նախագծում, որի պատճենումը թանկ է արժենալու, բայց կարող է տեղափոխվել (օրինակ, `sort()` ֆունկցիայում), ապա այն օժտեք տեղափոխման գործողությամբ կամ `swap()`-ով, կամ էլ՝ երկուսը միասին։ ?? Ուշադրություն դարձրեք, որ ստանդարտ գրադարանի կոնտեյներենրը (Գլուխ 11) և `string`-ը (§9.2.1) ունեն տեղափոխման արագ գործողություններ։


### 5.4.6 `hash<>`

Ստանդարտ գրադարանի `unordered_map<K,V>` տիպը հեշ-աղյուսակ է՝ բանալիի `K` տիպով և արժեքի `V` տիպով (§11.5)։ `X` տիպը որպես բանալի օգտագործելու համար պետք է սահմանենք `hash<X>`-ը։ Ստանդարտ գրադարանում դա արված է ընդհանուր օգտագործման տիպերի, ինչպիսին է `std::string`-ը, համար։


## 5.5 Խորհուրդներ

* Վերահսկեք օբյեկտների կառոցումը, պատճենումը, տեղափոխումը և քանդումը; §5.1.1; [CG: C.22]։
* Կոնստրուկտորները, վերագրումները և դեստրուկտորը սահմանեք որպես հործողությունների համաձայնեցված բազմություն; §5.1.1; [CG: C.22]։
* Սահմանեք կամ բոլոր հիմնական գործողությունները, կամ ոչ մեկը մի սահմանեք; §5.1.1; [CG: C.21]։
* Եթե լռելության կոնստրուկտորը, վերագրումը կամ դեստրուկտորը ձեզ համար ընդունելի են, ապա թող որ դրանք գեներացվեն կոմպիլյատորի կողմից (ինքնուրույն մի՛ գրեք); §5.1.1; [CG: C.20]։
* Եթե դասը ցուցիչ անդամ ունի, ապա հավանաբար դրա համար կպահանջվեն օգտագործողի սահմանած կան ջնջված դեստրուկտոր, պատճենման և տեղափոխման գործողություններ;; §5.1.1; [CG: C.32] [CG: C.33]։ ??
* Եթե դասը դեստրուկտոր ունի, ապա հավանաբար դրա համար կպահանջվեն օգտագործողի սահմանած կամ ջնջված պատճենի և տեղափոխման գործողություններ; §5.2.1։ ??
* Լռելությամբ մեկ արգումենտ ունեցող կոնստրուկտորը սահմանեք որպես `explicit`; §5.1.1; [CG: C.46]: ??
* Եթե դասի անդամն ունի իմաստալից լռելության արժեք, ապա այն գրեք որպես անդամի սկզբնարժեքավորիչ; §5.1.3; [CG: C.48]։
* Եթե տիպի համար պատճենման լռելությամբ որոշված վարքն ընդունելի չէ, ապա վերասահմանեք կամ արգելեք պատճենումը; [CG: C.61]։ ??
* Կոնտեյներները վերադարձրեք որպես արժեք (հույս դնելով արդյունավետ տեղափոխման վրա); §5.2.2; [CG: F.20]։
* Մեծ օպերանդների համար օգտագործեք արգումենտի՝ `const` հղումով տիպեր; §5.2.2; [CG: F.16]։
* Ապահովեք ռեսուրսների խիստ հսկողություն. այսինքն՝ երբեք թույլ մի տվել մի բան արտահոսք, որը ռեսուրս եք համարում; §5.3; [CG: R.1]։
* Եթե դասը ռեսուրսների նկարագրիչ է, ապա դրան անհրաժեշտ են օգտագոծողի սահմանած կոնստրուկտոր, դեստրուկտոր և ոչ-լռելության պատճենի գործողություն; §5.3; [CG: R.1]։
* Սովորական օգտագործմանը նմանակելու համար վերաբեռնեք գործողությունները; §5.4; [CG: C.160]։ ??
* Հետևեք ստանդարտ գրադարանի կոնտեյներների նախագծման եղանակին; §5.4.2; [CG: C.100]։

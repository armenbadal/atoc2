# 6 Կաղապարներ

_Այստեղ կարող է լինել ձեր մեջբերումը։_

_— Բ. Ստրոուստրուպ_


* [Ներածություն](#61-Ներածություն)
* [Պարամետրիզացված տիպեր](#62-Պարամետրիզացված-տիպեր)
    * Կաղապարների սահմանափակումներով արգումենտներ
    * Value Template Arguments
    * Template Argument Deduction
* Պարամետրիզացված գործողություններ
    * Ֆունկցիաների կաղապարներ
    * Ֆունկցիա օբյեկտներ
    * Լամբդա արտահայտություններ
* Template Mechanisms
    * Variable Templates;
    * Aliases;
    * Compile-Time if
* Խորհուրդներ


## 6.1 Ներածություն

Միշտ չէ, որ `vector` օգտագործողն ուզում է օգտագործել `double` արժեքների վեկտոր։ Վեկտորն ընդհանուր հասկացություն է՝ անկախ սահող կետով թվի ներկայացումից։ Հետևաբար վեկտորի տարրի տիպը պետք է ներկայացվի վեկտորից անկախ։ _Կաղապարը_ (template) դաս կամ ֆունկցիա է, որը մենք պարամետրիզացնում ենք տիպերի կամ արժեքների հավաքածույով։ Կաղապարներն օգտագործում ենք այնպիսի գաղափարների ներկայացման համար, որոնք ավելի հստակ են ընկալվում որպես ինչ֊որ ընդհանուր բան, որից կարող ենք գեներացնել կոնկրետ տիպեր ու ֆունկցիաներ՝ նշելով արգումենտները, ինչպես վեկտորի տարրի `double` տիպը։ ??

## 6.2 Պարամետրիզացված տիպեր

«`double`֊երի վեկտոր» տիպը կարող ենք ընդհանրացնել որպես «ինչ֊որ բաների վեկտոր»՝ այն կաղապար դարձնելով և `double`֊ը տիպի պարամետրով փոխարինելով։ Օրինակ.

```C++
template<typename T>
class Vector {
private:
    T* elem;  // elem֊ը ցույց է տալիս T տիպի sz հատ տարրերի զանգվածի
    int sz;
public:
    explicit Vector(int s);          // կոնստրուկտոր: հաստատել ինվարիանտը, ձեռք բերել ռեսուրսները
    ~Vector() { delete[] elem; }     // դեստրուկտոր: ազատել ռեսուրսները

    // ... պատճենի ու տեղափոխման գործողություններ ...

    T& operator[](int i);               // ոչ-const Vector֊ների համար
    const T& operator[](int i) const;   // const Vector֊ների համար (§4.2.1)
    int size() const { return sz; }
};
```

`template<typename T>` նախդիրը `T`֊ն դարձնում է իրեն հաջորդող հայտարարության պարամետր։ Սա մաթեմատիկական _∀T_, կամ, ավելի ճիշտ, _∀T, որտեղ T-ն տիպ է_ գրառման C++֊ական համարժեքն է։ Եթե ուզում եք գրառել մաթեմատիկական _∀T այնպիսիք, որ P(T)_ պայմանը, ապա ձեզ պետ կգան կոնցեպտները (§6.2.1, §7.2)։ Տիպի պարամետրի ներկայացման համար `class` բառի օգտագործումը համարժեք է `typename`֊ի օգտագործմանը, և հին կոդերում հաճախ ենք տեսնում `template<class T>` նախդիրը։

Անդամ ֆունկցիաները կարող են սահմանվել նման եղանակով․

```C++
template<typename T>
Vector<T>::Vector(int s)
{
    if (s<0)
        throw Negative_size{};
    elem = new T[s];
    sz = s;
}

template<typename T>
const T& Vector<T>::operator[](int i) const
{
    if (i<0 || size()<=i)
        throw out_of_range{"Vector::operator[]"};
    return elem[i];
}
```

Այս սահմանումներն ունենալով կարող ենք սահմանել այսպիսի `Vector`֊ներ․

```C++
Vector<char> vc(200);      // 200 նիշերի վեկտոր
Vector<string> vs(17);     // 17 տողերի վեկտոր
Vector<list<int>> vli(45); // 45 int֊երի ցուցակների վեկտոր
```

`Vector<list<int>>` գրառման մեջ `>>` նիշերի զույգը ցույց է տալիս կաղապարի արգումենտների ցուցակի վերջը․ դա սխալ օգտագործված արտածման օպերատորը չէ։ Այլևս անհրաժեշտություն չկա, ինչպես C++98֊ում, երկու `>` նիշերի միջև բացատ թողնել։

`Vector`֊ները կարող ենք օգտագործել այսպես․

```C++
void write(const Vector<string>& vs) // մի քանի տողերի Vector
{
    for (int i = 0; i != vs.size(); ++i)
        cout << vs[i] << '\n';
}
```

Մեր `Vector`֊ի հետ միջակայքերով-for (range-for) կառուցվածքն աշխատեցնելու համար պետք է սահմանենք համապատասխան `begin()` և `end()` ֆունկցիաները․

```C++
template<typename T>
T∗ begin(Vector<T>& x)
{
    return x.size() ? &x[0] : nullptr; // ցուցիչ առաջին տարրին, կամ nullptr
}

template<typename T>
T∗ end(Vector<T>& x)
{
    return begin(x)+x.size(); // ցուցիչ վերջին հաջորդող տարրին
}
```

Սրանք ունենալով կարող ենք գրել․

```C++
void f2(Vector<string>& vs) // մի քանի տողերի Vector
{
    for (auto& s : vs)
        cout << s << '\n';
}
```

Նման եղանակով որպես կաղապարներ կարող ենք սահմանել ցուցակները, վեկտորները, արտապատկերումները (այսնքն՝ ասոցեատիվ զանգվածները), չկարգավորված արտապատկերումները (այսինքն՝ հեշավորվող աղյուսակները) և այլն (Chapter 11)։

Կաղապարները կոպիլյացիայի ժամանակի մեխանիզմ են, այսինքն դրանց օգտագործումը, համեմատած ձեռքով գրված կոդի հետ, կատարման ժամանակի որևէ լրացուցիչ ծախս չի պահանջում։ ?? Փաստորեն `Vector<double>`֊ի համար գեներացված կոդը նույնական է 4֊րդ գլխում բերված `Vector`֊ի կոդի հետ։ Ավելին, ստանդարտ գրադարանի `vector<double>`֊ի համար գեներացված կոդն ակնհայտորեն շատ ավելի լավն է լինելու (քանի որ դրա իրականացման վրա շատ ավելի ջանք է գործադրված)։

Կաղապարը՝ կաղապարի արգումենտների բազմության հետ միասին, կոչվում է _նմուշահանում_ (_instantiation_) կամ _հատկորոշում_ (_specialization_)։ ?? Կոմպիլյացիայի ավելի ուշ փուլում, նմուշահանման ժամանակ, կոդ է գեներացվում ծրագրում օգտագործված յուրաքանչյուր նմուշահանման համար (§7.5)։ Գեներացված կոդի համատ տիպերի ստուգում է կատարվում, այսինքն ստացված կոդն ապահով է տիպերի տեսակետից այնպես, ինչպես ձեռքով գրած կոդը։ ?? Ցավոք, տիպերի այդ ստուգումը հաճախ իրականացվում է կոմպիլյացվիայի ուշ փուլերում, նմուշահանման ժամանակ։


### 6.2.1 Կաղապարների սահմանափակումներով արգումենտներ (C++20)

Հաճախ կաղապարն իմաստ է ստանում միայն այնպիսի արգումենտների համար, որոնք բավարարում են որոշակի պայմանների։ Օրինակ, `Vector`-ը սովորաբար ունենում է պատճենման գործողություն, և այդ դեպքում այն պետք է պահանջի, որ տարրերն էլ պատճենման գործողություն ունենան։ Այսինքն, պետք է պահանջենք, որ `Vector`֊ի կաղապարի արգումենտը լինի ոչ միայն `typename`, այլ `Element`, որտեղ «Element»֊ը սահմանում է այն պահանջները, որոնց պետք է բավարարի վեկտորի տարրը․

```C++
template<Element T>
class Vector {
private:
    T* elem;  // elem֊ը T տիպի sz տարրերի զանգվածի ցուցիչ է
    int sz;
    // ...
};
```

Այս `template<Element T>` նախդիրը C++-ի համարժեքն է մաթեմատիկական «բոլոր այնպիսի `T`-երի համար, որոնց համար ճշմարիտ է `Element(T)` պայմանը»։ Այսինքն՝ `Element`-ը պրեդիկատ է, որը ստուգում է, թե արդյոք `T`-ն բավարարում է `Vector`-ի դրած բոլոր պայմաններին։ Այսպիսի նախդիրը կոչվում է _կոնցեպտ_ (concept) (§7.2)։ Կաղապարի արգումենտը, որի համար կոնցեպտ է նշված, կոչվում է _սահմանափակումներով արգումենտ_, իսկ կաղապարը, որն ունի սահմանափակումներով արգումենտ, կոչվում է _սահմանափակումներով կաղապար_։

Կաղապարի պահանջներին չբավարարող տիպով կաղապարի նմուշահանումը կոմպիլյացիայի ժամանակի սխալ է։ ?? Օրինակ.

```C++
Vector<int> v1;     // լավ է. int-ը կարող ենք պատճենել
Vector<thread> v2;  // սխալ. ստանդարտ գրադարանի thread-ը չենք կարող պատճենել (§15.2)
```

Քանի որ C++20 ստադարտին նախորդող տարբերակներում կոնցեպտներն ապահովված չեն, հին կոդերում օգտագործվում են առանց սահմանափակումների կաղապարներ՝ պահանջները թողնելով փաստաթղթերում նկարագրվելուն։


### 6.2.2 Կաղապարի արժեք արգումենտներ

Ի լրումն տիպ արգումենտների, կաղապարը կարող է ստանալ նաև արժեք արգումենտներ։ Օրինակ.

```C++
template<typename T, int N>
struct Buffer {
    using value_type = T;
    constexprint size() { return N; }
    T[N];
    // ...
};
```

Այլանունը (value_type) և `constexpr` ֆունկցիան նախատեսված են կաղապարների արգումենտներին՝ օգտագործողին (միայն կարդալու) հաստանելիություն ապահովելու համար։ ??

Արժեք արգումենտներն օգտակար են շատ տեղերում։ Օրինակ, `Buffer`-ը մեզ հնարավորություն է տալիս ստեղծել կամայական չափի բուֆեր՝ առանց հիշողության ազատ (դինամիկ) տիրույթն օգտագործելու։

```C++
Buffer<char,1024> glob;  // նիշերի ընդհանուր բուֆեր (ստատիկ ստեղծվող)

void fct()
{
    Buffer<int,10> buf; // ամբողջ թվերի տեղային բուֆեր (ստեկում)
    // ...
}
```

Կաղապարի արժեք արգումենտը պետք է լինի հաստատուն արտահայտություն։


### 6.2.3 Կաղապարի արգումենտի դուրսբերումը

Դիտարկենք ստանդարտ գրադարանի `pair` կաղապարի օգտագործումը.

```C++
pair<int,double> p = {1,5.2};
```

Շատերը գտնում են, որ կաղապարի արգումենտների տիպերը թվարկելու անհրաժեշտությունը ձանձրալի է, այդ պատճառով ստանդարտ գրադարանն առաջարկում է `make_pair()` ֆունկցիան, որը իր արգումենտներից դուրս է բերում վերադարձվող `pair` կաղապարի արգումենտների տիպերը. ??

```C++
auto p = make_pair(1,5.2);    // p-ն pair<int,double> է
```

Այստեղից առաջ է գալիս ակնհայտ հարց. «Ինչո՞ւ չենք կարող կաղապարի արգումենտները դուրս բերել կոնստրուկտորի արգումենտներից»։ C++17-ում կարող ենք։ Այսինքն.

```C++
pair p = {1,5.2};    // p-ն pair<int,double> է
```

Սա միայն `pair`-ի հետ կապված խնդիր չէ. `make_` ֆունկցիաները շատ տարածված են։ Դիտարկենք մի օրինակ.

```C++
template<typename T>
class Vector {
public:
    Vector(int);
    Vector(initializer_list<T>);     // արժեքավորման ցուցակով կոնստրուկտոր
    // ...
};

Vector v1 {1,2,3};   // v1-ի տարրի տիպը դուրս բերել արժեքավորիչի տարրի տիպից
Vector v2 = v1;      // v2-ի տարրի տիպը դուրս բերել v1-ի տարրի տիպից

auto p = new Vector{1,2,3};   // p-ն ցույց է տալիս Vector<int>-ի

Vector<int> v3(1);  // այստեղ պետք է բացահայտ նշենք տարրի տիպը (այն ոչ մի տեղ չի հիշատակվում)
```

Կարճ ասած, սա պարզեցնում է գրառումը և կարող է բացառել կաղապարի լրացուցիչ արգումենտների տիպերի համար սխալ տիպեր գրելուց առաջացած անհարմարությունը։ ?? Այնուամենայնիվ, սա համադարման չէ։ Տիպի դուրսբերումը կարող է անակնկալներ մատուցել (թե՛ `make_` ֆունկցիաների, թե՛ կոնստրուկտորների կիրառման դեպքում)։ Դիտարկենք հետևյալը.

```C++
Vector<string> vs1 {"Hello", "World"};  // Vector<string>
Vector vs {"Hello", "World"};           // դուրս է բերվում Vector<const char*> (անակնկա՞լ է)
Vector vs2 {"Hello"s, "World"s};        // դուրս է բերում Vector<string>
Vector vs3 {"Hello"s, "World"};         // սխալ. արժեքավորման տիպը միատարր չէ
```

C-ոճի տեղային լիտերալի տիպը `const char*` է (§1.7.1)։ Եթե սա այն չէ, ինչ նկատի ունեիք, ապա օգտագործեք `s` վերջածանցը՝ ճիշտ `string` ստանալու համար (§9.2)։ Եթե արժեքավորող ցուցակի տարրերի տիպերը տարբեր են, ապա չենք կարող դուրս բերել միակ տիպ, հետևաբար ստանում ենք սխալ։

Երբ կաղապարի արգումենտը չի կարող դուրս բերվել կոնստրուկտորի արգումենտներից, մենք կարող ենք տրամադրել տիպի դուրսբերման հուշում։ Դիտարկենք հետևյալը.

```C++
template<typename T>
class Vector2 {
public:
    using value_type = T;
    // ...
    Vector2(initializer_list<T>);   // արժեքավորող ցուցակով կոնստրուկտոր

    template<typename Iter>
        Vector2(Iter b, Iter e);   // [b:e) միջակայքի կոնստրուկտոր ??
    // ...
};

Vector2 v1 {1,2,3,4,5};              // տարրի տիպը int է
Vector2 v2(v1.begin(), v1.begin() + 2);
```

Ակնհայտորեն `v2`-ը պետք է ունենա `Vector2<int>` տիպը, բայց առանց օգնության կոմպիլյատորը չի կարող արտածել դա։ Կոդից միայն երևում է, որ սահմանված է նույն տիպի արժեքների ցույգով կոնստրուկտոր։ Առանց լեզվի կողմից կոնցեպտների (§7.2) ապահովման, կոմպիլյատորը տիպերի մասին ոչինչ չի կարող ենթադրել։ Տիպի դուրսբերումը թույլ տալու համար կարող ենք `Vector2`-ի հայտարարությունից հետո ավելացնել «դուրսբերման հուշում». ??

```C++
template<typename Iter>
    Vector2(Iter,Iter) −> Vector2<typename Iter::value_type>;
```

Այսինքն, եթե տեսնում ենք իտերատորների զույգով արժեքավորված `Vector2`, ապա պետք է `Vector2::value_type`-ը դուրս բերել որպես իտերատորի արժեքի տիպ։ ??

Տիպի դուրսբերման հուշումները հաճախ կարող են նուրբ էֆեկտների բերել, այդ պատճառով էլ ավելի լավ է դասերը նախագծել այնպես, որ տիպի դուրսբերման հուշումների կարիք չլինի։ ?? Սակայն ստանդարտ գրադարանը լի է դասերով, որոնք (դեռ) կոնցեպտներ (§7.2) չեն օգտագործում և ունեն նշված երկիմաստությունները, այդ պատճառով էլ այնտեղ օգտագործվում են բավականին շատ տիպերի դուրսբերման հուշումներ (ցուցումներ ?)։ ??


## 6.3 Պարամետրիզացված գործողություններ

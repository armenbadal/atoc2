# 6 Կաղապարներ

_Այստեղ կարող է լինել ձեր մեջբերումը։_

_— Բ. Ստրոուստրուպ_


* [Ներածություն](#61-Ներածություն)
* [Պարամետրիզացված տիպեր](#62-Պարամետրիզացված-տիպեր)
    * Կաղապարների սահմանափակումներով արգումենտներ
    * Value Template Arguments
    * Template Argument Deduction
* Պարամետրիզացված գործողություններ
    * Ֆունկցիաների կաղապարներ
    * Ֆունկցիա օբյեկտներ
    * Լամբդա արտահայտություններ
* Template Mechanisms
    * Variable Templates;
    * Aliases;
    * Compile-Time if
* [Խորհուրդներ](#65-Խորհուրդներ)


## 6.1 Ներածություն

Միշտ չէ, որ `vector` օգտագործողն ուզում է օգտագործել `double` արժեքների վեկտոր։ Վեկտորն ընդհանուր հասկացություն է՝ անկախ սահող կետով թվի ներկայացումից։ Հետևաբար վեկտորի տարրի տիպը պետք է ներկայացվի վեկտորից անկախ։ _Կաղապարը_ (template) դաս կամ ֆունկցիա է, որը մենք պարամետրիզացնում ենք տիպերի կամ արժեքների հավաքածույով։ Կաղապարներն օգտագործում ենք այնպիսի գաղափարների ներկայացման համար, որոնք ավելի հստակ են ընկալվում որպես ինչ֊որ ընդհանուր բան, որից կարող ենք գեներացնել կոնկրետ տիպեր ու ֆունկցիաներ՝ նշելով արգումենտները, ինչպես վեկտորի տարրի `double` տիպը։ ??

## 6.2 Պարամետրիզացված տիպեր

«`double`֊երի վեկտոր» տիպը կարող ենք ընդհանրացնել որպես «ինչ֊որ բաների վեկտոր»՝ այն կաղապար դարձնելով և `double`֊ը տիպի պարամետրով փոխարինելով։ Օրինակ.

```C++
template<typename T>
class Vector {
private:
    T* elem;  // elem֊ը ցույց է տալիս T տիպի sz հատ տարրերի զանգվածի
    int sz;
public:
    explicit Vector(int s);          // կոնստրուկտոր: հաստատել ինվարիանտը, ձեռք բերել ռեսուրսները
    ~Vector() { delete[] elem; }     // դեստրուկտոր: ազատել ռեսուրսները

    // ... պատճենի ու տեղափոխման գործողություններ ...

    T& operator[](int i);               // ոչ-const Vector֊ների համար
    const T& operator[](int i) const;   // const Vector֊ների համար (§4.2.1)
    int size() const { return sz; }
};
```

`template<typename T>` նախդիրը `T`֊ն դարձնում է իրեն հաջորդող հայտարարության պարամետր։ Սա մաթեմատիկական _∀T_, կամ, ավելի ճիշտ, _∀T, որտեղ T-ն տիպ է_ գրառման C++֊ական համարժեքն է։ Եթե ուզում եք գրառել մաթեմատիկական _∀T այնպիսիք, որ P(T)_ պայմանը, ապա ձեզ պետ կգան կոնցեպտները (§6.2.1, §7.2)։ Տիպի պարամետրի ներկայացման համար `class` բառի օգտագործումը համարժեք է `typename`֊ի օգտագործմանը, և հին կոդերում հաճախ ենք տեսնում `template<class T>` նախդիրը։

Անդամ ֆունկցիաները կարող են սահմանվել նման եղանակով․

```C++
template<typename T>
Vector<T>::Vector(int s)
{
    if (s<0)
        throw Negative_size{};
    elem = new T[s];
    sz = s;
}

template<typename T>
const T& Vector<T>::operator[](int i) const
{
    if (i<0 || size()<=i)
        throw out_of_range{"Vector::operator[]"};
    return elem[i];
}
```

Այս սահմանումներն ունենալով կարող ենք սահմանել այսպիսի `Vector`֊ներ․

```C++
Vector<char> vc(200);      // 200 նիշերի վեկտոր
Vector<string> vs(17);     // 17 տողերի վեկտոր
Vector<list<int>> vli(45); // 45 int֊երի ցուցակների վեկտոր
```

`Vector<list<int>>` գրառման մեջ `>>` նիշերի զույգը ցույց է տալիս կաղապարի արգումենտների ցուցակի վերջը․ դա սխալ օգտագործված արտածման օպերատորը չէ։ Այլևս անհրաժեշտություն չկա, ինչպես C++98֊ում, երկու `>` նիշերի միջև բացատ թողնել։

`Vector`֊ները կարող ենք օգտագործել այսպես․

```C++
void write(const Vector<string>& vs) // մի քանի տողերի Vector
{
    for (int i = 0; i != vs.size(); ++i)
        cout << vs[i] << '\n';
}
```

Մեր `Vector`֊ի հետ միջակայքերով-for (range-for) կառուցվածքն աշխատեցնելու համար պետք է սահմանենք համապատասխան `begin()` և `end()` ֆունկցիաները․

```C++
template<typename T>
T∗ begin(Vector<T>& x)
{
    return x.size() ? &x[0] : nullptr; // ցուցիչ առաջին տարրին, կամ nullptr
}

template<typename T>
T∗ end(Vector<T>& x)
{
    return begin(x)+x.size(); // ցուցիչ վերջին հաջորդող տարրին
}
```

Սրանք ունենալով կարող ենք գրել․

```C++
void f2(Vector<string>& vs) // մի քանի տողերի Vector
{
    for (auto& s : vs)
        cout << s << '\n';
}
```

Նման եղանակով որպես կաղապարներ կարող ենք սահմանել ցուցակները, վեկտորները, արտապատկերումները (այսնքն՝ ասոցեատիվ զանգվածները), չկարգավորված արտապատկերումները (այսինքն՝ հեշավորվող աղյուսակները) և այլն (Chapter 11)։

Կաղապարները կոպիլյացիայի ժամանակի մեխանիզմ են, այսինքն դրանց օգտագործումը, համեմատած ձեռքով գրված կոդի հետ, կատարման ժամանակի որևէ լրացուցիչ ծախս չի պահանջում։ ?? Փաստորեն `Vector<double>`֊ի համար գեներացված կոդը նույնական է 4֊րդ գլխում բերված `Vector`֊ի կոդի հետ։ Ավելին, ստանդարտ գրադարանի `vector<double>`֊ի համար գեներացված կոդն ակնհայտորեն շատ ավելի լավն է լինելու (քանի որ դրա իրականացման վրա շատ ավելի ջանք է գործադրված)։

Կաղապարը՝ կաղապարի արգումենտների բազմության հետ միասին, կոչվում է _նմուշահանում_ (_instantiation_) կամ _հատկորոշում_ (_specialization_)։ ?? Կոմպիլյացիայի ավելի ուշ փուլում, նմուշահանման ժամանակ, կոդ է գեներացվում ծրագրում օգտագործված յուրաքանչյուր նմուշահանման համար (§7.5)։ Գեներացված կոդի համատ տիպերի ստուգում է կատարվում, այսինքն ստացված կոդն ապահով է տիպերի տեսակետից այնպես, ինչպես ձեռքով գրած կոդը։ ?? Ցավոք, տիպերի այդ ստուգումը հաճախ իրականացվում է կոմպիլյացվիայի ուշ փուլերում, նմուշահանման ժամանակ։


### 6.2.1 Կաղապարների սահմանափակումներով արգումենտներ (C++20)

Հաճախ կաղապարն իմաստ է ստանում միայն այնպիսի արգումենտների համար, որոնք բավարարում են որոշակի պայմանների։ Օրինակ, `Vector`-ը սովորաբար ունենում է պատճենման գործողություն, և այդ դեպքում այն պետք է պահանջի, որ տարրերն էլ պատճենման գործողություն ունենան։ Այսինքն, պետք է պահանջենք, որ `Vector`֊ի կաղապարի արգումենտը լինի ոչ միայն `typename`, այլ `Element`, որտեղ «Element»֊ը սահմանում է այն պահանջները, որոնց պետք է բավարարի վեկտորի տարրը․

```C++
template<Element T>
class Vector {
private:
    T* elem;  // elem֊ը T տիպի sz տարրերի զանգվածի ցուցիչ է
    int sz;
    // ...
};
```

Այս `template<Element T>` նախդիրը C++-ի համարժեքն է մաթեմատիկական «բոլոր այնպիսի `T`-երի համար, որոնց համար ճշմարիտ է `Element(T)` պայմանը»։ Այսինքն՝ `Element`-ը պրեդիկատ է, որը ստուգում է, թե արդյոք `T`-ն բավարարում է `Vector`-ի դրած բոլոր պայմաններին։ Այսպիսի նախդիրը կոչվում է _կոնցեպտ_ (concept) (§7.2)։ Կաղապարի արգումենտը, որի համար կոնցեպտ է նշված, կոչվում է _սահմանափակումներով արգումենտ_, իսկ կաղապարը, որն ունի սահմանափակումներով արգումենտ, կոչվում է _սահմանափակումներով կաղապար_։

Կաղապարի պահանջներին չբավարարող տիպով կաղապարի նմուշահանումը կոմպիլյացիայի ժամանակի սխալ է։ ?? Օրինակ.

```C++
Vector<int> v1;     // լավ է. int-ը կարող ենք պատճենել
Vector<thread> v2;  // սխալ. ստանդարտ գրադարանի thread-ը չենք կարող պատճենել (§15.2)
```

Քանի որ C++20 ստադարտին նախորդող տարբերակներում կոնցեպտներն ապահովված չեն, հին կոդերում օգտագործվում են առանց սահմանափակումների կաղապարներ՝ պահանջները թողնելով փաստաթղթերում նկարագրվելուն։


### 6.2.2 Կաղապարի արժեք արգումենտներ

Ի լրումն տիպ արգումենտների, կաղապարը կարող է ստանալ նաև արժեք արգումենտներ։ Օրինակ.

```C++
template<typename T, int N>
struct Buffer {
    using value_type = T;
    constexprint size() { return N; }
    T[N];
    // ...
};
```

Այլանունը (value_type) և `constexpr` ֆունկցիան նախատեսված են կաղապարների արգումենտներին՝ օգտագործողին (միայն կարդալու) հաստանելիություն ապահովելու համար։ ??

Արժեք արգումենտներն օգտակար են շատ տեղերում։ Օրինակ, `Buffer`-ը մեզ հնարավորություն է տալիս ստեղծել կամայական չափի բուֆեր՝ առանց հիշողության ազատ (դինամիկ) տիրույթն օգտագործելու։

```C++
Buffer<char,1024> glob;  // նիշերի ընդհանուր բուֆեր (ստատիկ ստեղծվող)

void fct()
{
    Buffer<int,10> buf; // ամբողջ թվերի տեղային բուֆեր (ստեկում)
    // ...
}
```

Կաղապարի արժեք արգումենտը պետք է լինի հաստատուն արտահայտություն։


### 6.2.3 Կաղապարի արգումենտի դուրսբերումը

Դիտարկենք ստանդարտ գրադարանի `pair` կաղապարի օգտագործումը.

```C++
pair<int,double> p = {1,5.2};
```

Շատերը գտնում են, որ կաղապարի արգումենտների տիպերը թվարկելու անհրաժեշտությունը ձանձրալի է, այդ պատճառով ստանդարտ գրադարանն առաջարկում է `make_pair()` ֆունկցիան, որը իր արգումենտներից դուրս է բերում վերադարձվող `pair` կաղապարի արգումենտների տիպերը. ??

```C++
auto p = make_pair(1,5.2);    // p-ն pair<int,double> է
```

Այստեղից առաջ է գալիս ակնհայտ հարց. «Ինչո՞ւ չենք կարող կաղապարի արգումենտները դուրս բերել կոնստրուկտորի արգումենտներից»։ C++17-ում կարող ենք։ Այսինքն.

```C++
pair p = {1,5.2};    // p-ն pair<int,double> է
```

Սա միայն `pair`-ի հետ կապված խնդիր չէ. `make_` ֆունկցիաները շատ տարածված են։ Դիտարկենք մի օրինակ.

```C++
template<typename T>
class Vector {
public:
    Vector(int);
    Vector(initializer_list<T>);     // արժեքավորման ցուցակով կոնստրուկտոր
    // ...
};

Vector v1 {1,2,3};   // v1-ի տարրի տիպը դուրս բերել արժեքավորիչի տարրի տիպից
Vector v2 = v1;      // v2-ի տարրի տիպը դուրս բերել v1-ի տարրի տիպից

auto p = new Vector{1,2,3};   // p-ն ցույց է տալիս Vector<int>-ի

Vector<int> v3(1);  // այստեղ պետք է բացահայտ նշենք տարրի տիպը (այն ոչ մի տեղ չի հիշատակվում)
```

Կարճ ասած, սա պարզեցնում է գրառումը և կարող է բացառել կաղապարի լրացուցիչ արգումենտների տիպերի համար սխալ տիպեր գրելուց առաջացած անհարմարությունը։ ?? Այնուամենայնիվ, սա համադարման չէ։ Տիպի դուրսբերումը կարող է անակնկալներ մատուցել (թե՛ `make_` ֆունկցիաների, թե՛ կոնստրուկտորների կիրառման դեպքում)։ Դիտարկենք հետևյալը.

```C++
Vector<string> vs1 {"Hello", "World"};  // Vector<string>
Vector vs {"Hello", "World"};           // դուրս է բերվում Vector<const char*> (անակնկա՞լ է)
Vector vs2 {"Hello"s, "World"s};        // դուրս է բերում Vector<string>
Vector vs3 {"Hello"s, "World"};         // սխալ. արժեքավորման տիպը միատարր չէ
```

C-ոճի տեղային լիտերալի տիպը `const char*` է (§1.7.1)։ Եթե սա այն չէ, ինչ նկատի ունեիք, ապա օգտագործեք `s` վերջածանցը՝ ճիշտ `string` ստանալու համար (§9.2)։ Եթե արժեքավորող ցուցակի տարրերի տիպերը տարբեր են, ապա չենք կարող դուրս բերել միակ տիպ, հետևաբար ստանում ենք սխալ։

Երբ կաղապարի արգումենտը չի կարող դուրս բերվել կոնստրուկտորի արգումենտներից, մենք կարող ենք տրամադրել տիպի դուրսբերման հուշում։ Դիտարկենք հետևյալը.

```C++
template<typename T>
class Vector2 {
public:
    using value_type = T;
    // ...
    Vector2(initializer_list<T>);   // արժեքավորող ցուցակով կոնստրուկտոր

    template<typename Iter>
        Vector2(Iter b, Iter e);   // [b:e) միջակայքի կոնստրուկտոր ??
    // ...
};

Vector2 v1 {1,2,3,4,5};              // տարրի տիպը int է
Vector2 v2(v1.begin(), v1.begin() + 2);
```

Ակնհայտորեն `v2`-ը պետք է ունենա `Vector2<int>` տիպը, բայց առանց օգնության կոմպիլյատորը չի կարող արտածել դա։ Կոդից միայն երևում է, որ սահմանված է նույն տիպի արժեքների ցույգով կոնստրուկտոր։ Առանց լեզվի կողմից կոնցեպտների (§7.2) ապահովման, կոմպիլյատորը տիպերի մասին ոչինչ չի կարող ենթադրել։ Տիպի դուրսբերումը թույլ տալու համար կարող ենք `Vector2`-ի հայտարարությունից հետո ավելացնել «դուրսբերման հուշում». ??

```C++
template<typename Iter>
    Vector2(Iter,Iter) −> Vector2<typename Iter::value_type>;
```

Այսինքն, եթե տեսնում ենք իտերատորների զույգով արժեքավորված `Vector2`, ապա պետք է `Vector2::value_type`-ը դուրս բերել որպես իտերատորի արժեքի տիպ։ ??

Տիպի դուրսբերման հուշումները հաճախ կարող են նուրբ էֆեկտների բերել, այդ պատճառով էլ ավելի լավ է դասերը նախագծել այնպես, որ տիպի դուրսբերման հուշումների կարիք չլինի։ ?? Սակայն ստանդարտ գրադարանը լի է դասերով, որոնք (դեռ) կոնցեպտներ (§7.2) չեն օգտագործում և ունեն նշված երկիմաստությունները, այդ պատճառով էլ այնտեղ օգտագործվում են բավականին շատ տիպերի դուրսբերման հուշումներ (ցուցումներ ?)։ ??


## 6.3 Պարամետրիզացված գործողություններ

Կաղապարներն ունեն շատ ավելի կիրառություններ, քան պարզապես կոնտեյների պարամետրիզացումը տարի տիպով։ Մասնավորապես, դրանք լայնորեն օգտագործվում են ստանդարտ գրադարանի տիպերի ու ալգորիթմների պարամետրիզացման համար (§11.6, §12.6)։

Գործողությունների՝ տիպերով կամ արժեքներով պարամետրիզացումն արտահայտելու երեք ճանապարհ կա.

* Կաղապար ֆունկցիա, ??
* Ֆունկցիա օբյեկտ. մի օբյեկտ, որը կարող է տվյալներ ունենալ և կանչվել ինչպես ֆունկցիա,
* Լամբդա արտահայտություն. ֆունկցիա օբյեկտի համառոտ գրառում։


### 6.3.1 Կաղապար ֆունկցիա

Կարող ենք գրել ֆունկցիա, որը հաշվում է որևէ հաջորդականության տարրերի արժեքների գումարը, որոնք կարելի է թվարկել միջակայքերի `for` կառուցվածքով։ Այսպես.

```C++
template<typename Sequence, typename Value>
Value sum(const Sequence& s, Value v)
{
    for (auto x : s)
        v += x;
    return v;
}
```

Այստեղ կաղապարի `Value` արգումենտը և ֆունկցիայի `v` արգումենտը նախատեսված են կանչողին հնարավորություն տալու նշել տարրի տիպը և կուտակիչի (accumulator. փոփոխական, որի մեջ կուտակվելու է գումարի արժեքը]) սկզբնական արժեքը.

```C++
void user(Vector<int>& vi, list<double>& ld, vector<complex<double>>& vc)
{
    int x = sum(vi,0);                  // the sum of a vector of ints (add ints)
    double d = sum(vi,0.0);             // the sum of a vector of ints (add doubles)
    double dd = sum(ld,0.0);            // the sum of a list of doubles
    auto z = sum(vc,complex{0.0,0.0});  // the sum of a vector of complex<double>s
}
```

`int`-երի գումարը `double` արժեքի մեջ կուտակելու նպատակը կարող է լինել այն, որ հաջողությամբ մշակվեն այն թվերը, որոնց արժեքը մեծ է `int`-ի ամենամեծ թույլատրելի արժեքից։ Ուշադրություն դարձրեք, թե ինչպես են `sum<Sequence,Value>` գրառման համար կաղապարի արգումենտների տիպերը դուրս բերվում ֆունկցիայի արգումենտներից։ Բարեբախտաբար, կարիք չունենք բացահայտ նշել այդ տիպերը։

`sum()`-ը ստանդարտ գրադարանի `accumulate()` (§14.3) ֆունկցիայի պարզեցված տարբերակն է։

Կաղապար ֆունկցիան կարող է դասի անդամ լինել, բայց ոչ վիրտուալ։ Կոմպիլյատորը կարող է չիմանալ ծրագրում այդպիսի կաղապարի բոլոր նմուշահանումների մասին, հետևաբար կարող է և չգեներացնել `vtbl`-ը (§4.4)։


### 6.3.2 Ֆունկցիա օբյեկտներ

Կաղապարի մի օգտակար օգտագործման մի մասնավոր տեսակ է _ֆունկցիա օբյեկտը_ (երբեմն կոչված _ֆունկտոր_), որոնք օգտագործվում են ֆունկցիայի պես կանչվող օբյեկտներ սահմանելու համար։ ??

```C++
template<typename T>
class Less_than {
    const T val;   // համեմատման արժեք
public:
    Less_than(const T& v) :val{v} { }
    bool operator()(const T& x) const { return x<val; } // կանչի գործողություն
};
```

Ֆունկցիան՝ անվանված `operator()`, իրականացնում է «ֆունկցիայի կանչ», «կանչ» կամ «կիրառում» գործողությունը՝ `()`։ ?? ⚠

Կարող ենք սահմանել `Less_than` տիպի անվանված փոփոխականներ՝ տարբեր արգումենտների տիպերով.

```C++
Less_than lti {42};                // lti(i)-ն i-ն կհամեմատի 42-ի հետ՝ < գործողությամբ (i < 42)
Less_than lts {"Backus"s};         // lts(s)-ն s-ը կհամեմատի "Backus"-ի հետ՝ օգտագործելով < գործողությունը (s < "Backus")
Less_than<string> lts2 {"Naur"};   // "Naur"-ը C ոճի տող է, ուրեմն, ճիշտ < գործողությունը ստանալու համար, պետք է գրենք <string>-ը
```

Այս օբյեկտը կարող ենք «կանչել» ճիշտ այնպես, ինչպես կանչում ենք ֆունկցիան.

```C++
void fct(int n, const string & s)
{
    bool b1 = lti(n);    // true՝ եթե n < 42
    bool b2 = lts(s);    // true՝ եթե s < "Backus"
    // ...
}
```

Այսպիսի ֆունկցիա իբյեկները լայնորեն օգտագործվում են որպես ալգորիթմների արգումենտներ։ Օրինակ, կարող ենք հաշվել այն արժեքների քանակը, որոնց համար պրեդիկատը վերադարձնում է `true`.

```C++
template<typename C, typename P>
     // requires Sequence<C> && Callable<P,Value_type<P>>
int count(const C& c, P pred)
{
    int cnt = 0;
    for (const auto& x : c)
        if (pred(x))
            ++cnt;
    return cnt;
}
```

_Պրեդիկատը_ ինչ-որ բան է, որը կարող ենք կիրառել՝ `true` կամ `false` ստանալու համար։ Օրինակ,

```C++
void f(const Vector<int>& vec, const list<string>& lst, int x, const string& s)
{
    cout << x << "-ից փոքր արժեքների քանակը " << count(vec,Less_than{x}) << '\n';
    cout << s << "-ից փոքր արժեքների քանակը " << count(lst,Less_than{s}) << '\n';
}
```

Այստեղ `Less_than{x}`-ը կառուցում է `Less_than<int>` տիպի օբյեկտ, որի համար կանչի գործողությունը համեմատում է `x` անունով `int` արժեքը։ `Less_than{s}`-ը կառուցում է օբյեկտ, որը համեմատում է `s` անունով `string` արժեքը։ Այս ֆունկցիա օբյեկտների գեղեցկությունն այն է, որ դրանք իրենց մեջ են պահում նաև համեմատվող արժեքը։ Մեզ պետք չէ առանձին ֆունկցիա սահմանել ամեն մի արժեքի (և ամեն մի տիպի) համար, և պետք չէ ավելորդ գլոբալ փոփոխականներ ներմուծել՝ արժեքները պահելու համար։ Բացի այդ, `Less_than`-ի պես հասարակ ֆունկցիայի համար կատարվում է շատ պարզ ներդրում, հետևաբար՝ `Less_than`-ի կանչն ավելի արդյունավետ է ստացվում, քան ֆունկցիայի անուղղակի կանչը։ Տվյալները պահելը, ինչպես նաև կանչի արդյունավետությունը ֆունկցիա օբյեկտներին հատկապես օգտակար են դարձնում  ալգորիթմների արգումենտներ օգտագործելիս։ ??

Կարևոր գործողությունների իմաստը սահմանելու համար օգտագործվող ֆունկցիա օբյեկտները (ինպիսին է `Less_than`-ը `count()`-ի համար) կոչվում են _գործելակերպի օբյեկտներ_ (_policy objects_):


### 6.3.3 Լամբդա արտահայտություններ






## 6.5 Խորհուրդներ

* Օգտագործեք կաղապարները տարբեր տիպերի նկատմամբ կիրառելի ալգորիթմներն արտահայտելու համար; §6.1; [CG: T.2]։
* Օգտագործեք կաղապարները կոնտեյներներն արտահայտելու համար; §6.2; [CG: T.3]։
* Կաղապարներն օգտագործեք կոդի վերացականության մակարդակը բարձրացնելու համար; §6.2; [CG: T.1]։
* Կաղապարները տիպերի տեսակետից ապահով են, բայց ստուգումը շատ ուշ է կատարվում; §6.2։
* Թույլ տվեք, որ կոնստրուկտորները կամ ֆուկցիայի կաղապարները դուրս բերեն դասի կաղապարի արգումենտների տիպերը; §6.2.3։
* Ֆունկցիա օբյեկտները օգտագործեք որպես ալգորիթմների արգումենտներ; §6.3.2; [CG: T.40]։
* Օգտագործեք լամբդա արտահայտություն, եթե ձեզ պետք է պարզ ֆունկցիա օբյեկտ միայն մեկ տեղում; §6.3.2։ ??
* Վիրտուալ ֆունկցիա անդամը չի կարող անդամ ֆունկցիայի կաղապար; §6.3.1։
* Կաղապարների այլանուններն օգտագործեք գրառումը պարզեցնելու և իրականացման մանրամասները ծածկելու համար; §6.4.2։
* Կաղապարն օգտագործելի համոզվեք, որ դրա սահմանումը (ոչ թե միայն հայտարարությունը) տեսանելիության տիրույթում է; §7.5։
* Կաղապարները տրամադրում են կոմպիլյացիայի ժամանակի «duck typing»; §7.5։ ??
* Կաղապարներն առանձին չեն կոմպիլյացվում. `#include` հրահանգով կաղապարների սահմանումները կցեք բոլոր այն թարգմանության միավորներին, որտեղ դրանք օգտագործվում են։
